# Design Databases

Database Design은 데이터베이스 시스템을 설계하는 과정을 의미합니다. 데이터베이스는 조직이나 기업에서 사용되는 중요한 자산으로, 데이터를 효율적이고 안정적으로 저장, 관리, 검색할 수 있도록 구조화된 형태입니다. 데이터베이스 시스템은 사용자의 요구를 충족시키기 위해 데이터를 효율적으로 조작하고 처리할 수 있는 기능을 제공합니다.

Database Design은 다양한 측면에서 데이터베이스 시스템을 설계하는 과정을 의미합니다. 주요 목표는 데이터의 일관성, 무결성, 보안 및 효율성을 보장하는 것입니다. 다음은 데이터베이스 설계의 주요 단계입니다.

1. 요구사항 분석(Understand the requirements): 데이터베이스를 사용하는 목적과 요구사항을 파악하고 문서화합니다. 이 단계에서는 필요한 데이터와 그들 간의 관계를 정의합니다.

2. 개념적 설계(Build a Conceptual Model): 요구사항을 바탕으로 개념적 데이터 모델을 작성합니다. 일반적으로 개체-관계(Entity-Relationship) 모델이 사용됩니다. 이 모델은 엔티티(개체)와 엔티티 간의 관계를 표현하여 데이터베이스의 구조를 설계합니다.

3. 논리적 설계(Build a Logical Model): 개념적 설계를 기반으로 데이터베이스의 논리적 구조를 정의합니다. 일반적으로 관계형 데이터베이스 모델을 사용하여 테이블, 속성, 관계 등을 정의합니다.

4. 물리적 설계(Build a Physical Model): 논리적 설계를 구체화하여 데이터베이스를 실제로 구현할 수 있는 물리적 구조를 설계합니다. 이 단계에서는 데이터 저장소, 인덱스, 파티셔닝 등과 같은 세부적인 사항을 고려합니다.

5. 구현 및 테스트: 데이터베이스를 구현하고 테스트합니다. 데이터베이스 관리 시스템(DBMS)을 사용하여 테이블을 생성하고 데이터를 삽입, 갱신, 삭제하며, 쿼리와 인덱스를 최적화합니다.

6. 유지보수: 데이터베이스를 사용하면서 필요한 변경사항을 관리하고 유지보수합니다. 데이터베이스 성능 모니터링, 백업 및 복원, 보안 관리 등이 이에 해당합니다.

Database Design은 데이터베이스 시스템의 품질과 성능에 큰 영향을 미치는 중요한 단계입니다. 효과적인 Database Design을 통해 데이터의 일관성과 정확성을 유지하고 데이터 접근과 조작의 효율성을 높일 수 있습니다.

## Relationships

<img src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*AP5nkTsmghPOqU12qnyLTQ.png" />

다양한 관계 유형이 데이터베이스에서 사용됩니다. 가장 일반적인 관계 유형은 일대일(One-to-One), 일대다(One-to-Many), 다대다(Many-to-Many) 관계입니다. 각 관계 유형을 정의하고, 각각에 대한 상세한 예시를 설명하겠습니다.

1. 일대일(One-to-One) 관계:

   - 정의: 한 개체(또는 테이블)의 레코드가 다른 개체(또는 테이블)의 레코드와 하나씩 연결되는 관계입니다. 각 개체(또는 테이블)의 레코드는 다른 개체(또는 테이블)의 레코드와 한 번에 연결됩니다.
   - 예시: "사용자(User)" 테이블과 "프로필(Profile)" 테이블이 있을 때, 각 사용자는 하나의 프로필을 가지며, 각 프로필은 한 명의 사용자에게 속합니다. 이 경우, "사용자(User)" 테이블의 레코드와 "프로필(Profile)" 테이블의 레코드는 일대일 관계를 가집니다.

2. 일대다(One-to-Many) 관계:

   - 정의: 한 개체(또는 테이블)의 레코드가 다른 개체(또는 테이블)의 레코드와 일대다로 연결되는 관계입니다. 한 개체(또는 테이블)의 레코드는 다른 개체(또는 테이블)의 여러 레코드와 연결될 수 있지만, 다른 개체(또는 테이블)의 레코드는 한 개체(또는 테이블)의 레코드에만 연결됩니다.
   - 예시: "부서(Department)" 테이블과 "직원(Employee)" 테이블이 있을 때, 한 부서는 여러 직원을 가질 수 있지만, 한 직원은 하나의 부서에만 속합니다. 이 경우, "부서(Department)" 테이블의 레코드와 "직원(Employee)" 테이블의 레코드는 일대다 관계를 가집니다.

3. 다대다(Many-to-Many) 관계:
   - 정의: 한 개체(또는 테이블)의 레코드가 다른 개체(또는 테이블)의 레코드와 다대다로 연결되는 관계입니다. 한 개체(또는 테이블)의 레코드는 다른 개체(또는 테이블)

의 여러 레코드와 연결될 수 있으며, 다른 개체(또는 테이블)의 레코드도 한 개체(또는 테이블)의 여러 레코드와 연결될 수 있습니다.

- 예시: "학생(Student)" 테이블과 "과목(Subject)" 테이블이 있을 때, 한 학생은 여러 과목을 수강할 수 있고, 한 과목은 여러 학생에게서 수강될 수 있습니다. 이 경우, "학생(Student)" 테이블의 레코드와 "과목(Subject)" 테이블의 레코드는 다대다 관계를 가집니다. 이러한 다대다 관계는 중간 테이블인 "수강(Enrollment)" 테이블을 통해 구현될 수 있습니다. "수강(Enrollment)" 테이블은 "학생(Student)" 테이블과 "과목(Subject)" 테이블의 기본 키를 참조하는 열로 구성됩니다.

각 관계 유형은 다양한 형태의 데이터 관계를 표현할 수 있으며, 데이터베이스 설계에서 이러한 관계를 정확히 모델링하고 구현하는 것이 중요합니다.

## Conceptual Model

<img src="https://drawio-app.com/wp-content/uploads/2018/02/EntityRelationshipModel-HabitTrackerApp-Style2.png" />
<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*PkrBx5GRf2z4zokbexvQ_Q.png" />

Conceptual Models: Represents the entities and their relationships

Modeling Tools

- Microsfot Visio
- draw.io
- LucidCharts

Conceptual Models는 데이터베이스 설계의 한 단계로, 비즈니스 요구사항을 기반으로 데이터베이스의 구조를 추상적으로 표현하는 모델입니다. 이 모델은 데이터베이스의 개념적 설계를 위해 사용됩니다. 주로 개체-관계(Entity-Relationship) 모델이나 UML(Unified Modeling Language)을 활용하여 표현됩니다.

Conceptual Models은 다음과 같은 주요 요소로 구성됩니다:

1. 엔티티(개체): 엔티티는 현실 세계에서 독립적으로 존재하고 식별 가능한 사물이나 개념을 나타냅니다. 예를 들어, "고객", "주문", "제품" 등이 엔티티가 될 수 있습니다. 엔티티는 데이터베이스에서 테이블로 표현될 수 있습니다.

2. 속성: 속성은 엔티티의 특성이나 성질을 나타냅니다. 각 엔티티는 여러 개의 속성을 가질 수 있으며, 속성은 데이터베이스 테이블의 열(Column)로 표현됩니다. 예를 들어, "고객" 엔티티의 속성으로는 "고객ID", "이름", "주소" 등이 있을 수 있습니다.

3. 관계: 관계는 엔티티 간의 연결을 나타냅니다. 예를 들어, "주문"과 "고객" 사이에는 "주문한 고객"이라는 관계가 있을 수 있습니다. 관계는 데이터베이스에서 외래 키(Foreign Key)로 표현될 수 있습니다.

Conceptual Models를 사용하여 데이터베이스 설계 단계에서 비즈니스 요구사항을 분석하고, 엔티티 간의 관계를 정의하고, 엔티티의 속성을 식별합니다. 이를 통해 개념적 데이터 모델을 작성하고, 이후의 논리적 설계와 물리적 설계 단계에서 구체화할 수 있습니다. Conceptual Models는 데이터베이스 구조의 기반을 마련하며, 데이터의 의미와 관계를 명확하게 정의하는 데 도움을 줍니다.

데이터베이스 설계의 Conceptual Models를 예시를 통해 설명해드리겠습니다.

가정해보겠습니다. 우리는 온라인 상점을 운영하고 있으며, 고객들이 제품을 주문하고 배송 받는 시스템을 구축하려고 합니다. 이를 바탕으로 Conceptual Models를 만들어보겠습니다.

1. 엔티티(개체):

   - "고객(Customer)": 고객의 정보를 나타내는 엔티티입니다. 속성으로는 "고객ID", "이름", "주소" 등이 있을 수 있습니다.
   - "제품(Product)": 판매하는 제품의 정보를 나타내는 엔티티입니다. 속성으로는 "제품ID", "제품명", "가격" 등이 있을 수 있습니다.
   - "주문(Order)": 고객이 주문한 제품의 정보를 나타내는 엔티티입니다. 속성으로는 "주문ID", "주문일자", "주문상태" 등이 있을 수 있습니다.

2. 속성:

   - "고객(Customer)" 엔티티의 속성: "고객ID", "이름", "주소" 등
   - "제품(Product)" 엔티티의 속성: "제품ID", "제품명", "가격" 등
   - "주문(Order)" 엔티티의 속성: "주문ID", "주문일자", "주문상태" 등

3. 관계:
   - "주문(Order)"과 "고객(Customer)" 사이의 관계: 한 명의 고객은 여러 개의 주문을 생성할 수 있으므로, "주문(Order)" 엔티티와 "고객(Customer)" 엔티티는 일대다 관계를 가집니다.
   - "주문(Order)"과 "제품(Product)" 사이의 관계: 한 개의 주문에는 여러 개의 제품이 포함될 수 있으므로, "주문(Order)" 엔티티와 "제품(Product)" 엔티티는 일대다 관계를 가집니다.

이렇게 구성된 Conceptual Models를 바탕으로 논리적 설계 단계에서는 각 엔티티와 속성을 테이블로 변환하고, 관계를 외래 키로 표현할 수 있습니다. 예를 들어, "고객(Customer)" 테이블에는 "고객ID", "이름", "주소" 컬럼이 있을 것이며, "주문(Order)" 테이블에는 "주문ID", "주

문일자", "주문상태" 컬럼이 있을 것입니다.

이렇게 설계된 논리적 구조를 기반으로 물리적 설계 단계에서는 실제 데이터베이스 시스템에 맞춰 테이블과 인덱스를 생성하고, 데이터베이스 관리 시스템(DBMS)을 사용하여 데이터를 저장, 관리, 검색할 수 있게 됩니다.

## Logical Models

<img src="https://drawio-app.com/wp-content/uploads/2018/02/EntityRelationshipModel-HabitTrackerApp-Style2.png" />

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*jCIahOA4ViNLB49NkdKr4A.png" />

Logical Models는 데이터베이스 설계의 한 단계로, Conceptual Models를 바탕으로 데이터베이스의 논리적 구조를 정의하는 모델입니다. Logical Models는 데이터베이스 시스템에서 사용되는 특정 데이터 모델에 맞게 엔티티, 속성, 관계 등을 구체화하여 표현합니다.

주로 사용되는 데이터 모델 중 가장 널리 알려진 것은 관계형 데이터 모델입니다. 관계형 데이터 모델에서는 테이블, 속성, 관계를 사용하여 데이터베이스의 구조를 설계합니다. Logical Models에서는 Conceptual Models에서 정의한 엔티티와 관계를 관계형 데이터 모델의 테이블과 관계로 변환하는 작업이 이루어집니다.

Logical Models의 주요 구성 요소는 다음과 같습니다:

1. 테이블: Conceptual Models의 엔티티를 테이블로 변환합니다. 각 테이블은 엔티티에 해당하며, 엔티티의 속성은 테이블의 열(Column)로 표현됩니다.

2. 열(속성): Conceptual Models의 속성을 테이블의 열로 변환합니다. 각 열은 속성에 해당하며, 데이터 유형과 제약 조건을 가지고 있습니다.

3. 키: Conceptual Models에서 정의한 키 개념을 테이블의 기본 키(Primary Key)와 외래 키(Foreign Key)로 변환합니다. 기본 키는 각 테이블에서 고유하게 식별되는 열로, 테이블의 레코드를 고유하게 식별하는 데 사용됩니다. 외래 키는 다른 테이블과의 관계를 나타내며, 관계를 형성하는 데 사용됩니다.

4. 관계: Conceptual Models에서 정의한 관계를 관계형 데이터 모델의 관계로 변환합니다. 주로 일대일(One-to-One), 일대다(One-to-Many), 다대다(Many-to-Many)와 같은 관계 유형이 사용됩니다.

Logical Models를 사용하여 데이터베이스 설계 단계에서 Conceptual Models를 구체화하고, 테이블, 열, 키, 관계 등의 구조를 정의합니다. 이를 바탕으로 물리적 설계 단계에서는 실제 데이터베이스 시스템에 맞는 방식으로 테이블을 생성하고 인덱스, 제약 조건 등을 추가합니다.

앞서 언급한 Conceptual Models를 기반으로 Logical Models의 예시를 들어보겠습니다.

가정해보겠습니다. 우리는 은행 시스템을 개발하고 있으며, 고객들의 계좌 정보를 관리하는 데이터베이스를 설계하려고 합니다. 이를 바탕으로 Logical Models를 만들어보겠습니다.

1. 테이블:

   - "고객(Customer)": 고객의 정보를 담고 있는 테이블입니다. "고객ID", "이름", "주소" 등의 열을 가질 수 있습니다.
   - "계좌(Account)": 고객의 계좌 정보를 담고 있는 테이블입니다. "계좌번호", "잔액", "개설일자" 등의 열을 가질 수 있습니다.

2. 열(속성):

   - "고객(Customer)" 테이블의 열: "고객ID", "이름", "주소" 등
   - "계좌(Account)" 테이블의 열: "계좌번호", "잔액", "개설일자" 등

3. 키:

   - "고객(Customer)" 테이블의 기본 키: "고객ID"
   - "계좌(Account)" 테이블의 기본 키: "계좌번호"
   - "계좌(Account)" 테이블의 외래 키: "고객ID" (고객과 계좌 사이의 관계를 나타냄)

4. 관계:
   - "고객(Customer)"과 "계좌(Account)" 테이블 사이의 관계: 한 명의 고객은 여러 개의 계좌를 가질 수 있으므로, "고객(Customer)" 테이블과 "계좌(Account)" 테이블은 일대다 관계를 가집니다.

위와 같이 구성된 Logical Models를 바탕으로 물리적 설계 단계에서는 실제 데이터베이스 시스템에 맞게 테이블을 생성하고 인덱스, 제약 조건 등을 추가하여 데이터를 저장하고 관리할 수 있습니다.

## Physical Models

- MySQL Workbench => File => New Model
- 테이블 이름을 작성할 때 일반적으로 복수형으로 작성합니다. 그 이유는 둘 이상의 데이터를 저장하기 위함입니다.

Physical Models는 데이터베이스 설계의 마지막 단계로, 논리적 모델(Logical Models)을 실제 데이터베이스 시스템에 구현할 수 있는 형태로 변환하는 모델입니다. Physical Models는 특정 데이터베이스 관리 시스템(DBMS)을 기준으로 데이터 구조, 저장 방식, 인덱싱, 파티셔닝 등의 세부 사항을 정의합니다.

Physical Models의 주요 구성 요소는 다음과 같습니다:

1. 데이터 타입: 논리적 모델의 속성을 실제 데이터베이스 시스템이 지원하는 데이터 타입으로 매핑합니다. 예를 들어, 문자열, 정수, 실수, 날짜 등의 데이터 타입을 선택할 수 있습니다.

2. 테이블 및 인덱스 생성: 논리적 모델의 테이블을 실제 데이터베이스 시스템의 테이블로 변환합니다. 테이블의 구조, 컬럼의 정의, 제약 조건 등을 명시합니다. 또한, 적절한 인덱스를 생성하여 데이터 검색과 조인의 성능을 향상시킵니다.

3. 파티셔닝: 대용량 데이터베이스에서 데이터의 저장과 관리를 효율적으로 하기 위해 파티셔닝을 적용할 수 있습니다. 파티셔닝은 데이터를 논리적 또는 물리적 기준에 따라 분할하여 저장하는 방법으로, 검색과 조작의 성능을 향상시킵니다.

4. 성능 튜닝: 데이터베이스 시스템의 성능을 향상시키기 위해 인덱스, 쿼리 최적화, 메모리 관리 등의 성능 튜닝을 수행합니다. 이 단계에서는 데이터베이스 시스템의 특성과 하드웨어 환경을 고려하여 최적의 설정을 결정합니다.

Physical Models는 실제 운영 환경에서 데이터베이스 시스템의 성능과 확장성을 최적화하기 위해 중요한 역할을 합니다. 이 모델을 기반으로 데이터베이스를 생성하고 구성함으로써 데이터의 저장, 검색, 갱신, 삭제 등을 효율적으로 수행할 수 있습니다.

앞서 언급한 Logical Models를 기반으로 Physical Models의 예시를 들어보겠습니다.

가정해보겠습니다. 우리는 학사 관리 시스템을 개발하고 있으며, 학생들의 성적 정보를 관리하는 데이터베이스를 설계하려고 합니다. 이를 바탕으로 Physical Models를 만들어보겠습니다.

1. 데이터 타입:

   - "학번(Student)" 열: 정수형(INT)
   - "이름(Name)" 열: 문자열(VARCHAR)
   - "과목(Subject)" 열: 문자열(VARCHAR)
   - "점수(Score)" 열: 실수형(FLOAT)

2. 테이블 및 인덱스 생성:

   - "학생(Student)" 테이블: "학번", "이름" 열로 구성됩니다.
   - "성적(Score)" 테이블: "학번", "과목", "점수" 열로 구성됩니다.
   - "학번(Student)" 열을 기준으로 "학생(Student)" 테이블에 기본 키를 생성합니다.
   - "학번(Student)" 열과 "과목(Subject)" 열을 기준으로 "성적(Score)" 테이블에 복합 키를 생성합니다.
   - "학번(Student)" 열과 "과목(Subject)" 열에 인덱스를 생성하여 데이터 검색 성능을 향상시킵니다.

3. 파티셔닝:

   - 대용량의 학생 데이터를 처리하기 위해 "학번(Student)"을 기준으로 수평 파티셔닝을 적용합니다. 예를 들어, 학번의 범위에 따라 데이터를 여러 파티션에 분할하여 저장합니다.

4. 성능 튜닝:
   - 쿼리 최적화: 자주 사용되는 쿼리의 성능을 향상시키기 위해 인덱스를 적절히 활용하고 쿼리 플랜을 최적화합니다.
   - 메모리 관리: 데이터베이스 시스템의 메모리 설정을 조정하여 데이터 캐싱과 버퍼링을 최적화합니다.

위와 같이 구성된 Physical Models를 바탕으로 데이터베이스 시스템에 데이터를 생성하고 적절한 인덱스를 생성하여 데이터 검색 성능을 향상시킬 수 있습니다. 또한, 파티셔닝을 통해 대용량 데이터 처리를 효율적으로 수행하고 성능 튜닝을 통해 데이터베이스 시스템의 성능을 최적화할 수 있습니다.

파티셔닝은 각 DBMS에 따라 구현 방식이 다를 수 있으며, 아래 예시는 MySQL에서의 파티셔닝을 보여줍니다. 다른 DBMS에서는 문법이나 절차가 다를 수 있으니 해당 DBMS의 공식 문서를 참조해야 합니다.

가정해보겠습니다. 우리는 학사 관리 시스템을 위한 MySQL 데이터베이스를 설계하고 있으며, "성적(Score)" 테이블을 파티셔닝하려고 합니다. "학번(Student)"을 기준으로 수평 파티셔닝을 적용하고자 합니다.

아래는 MySQL에서 파티셔닝을 설정하는 예시 코드입니다:

```sql
CREATE TABLE Score (
    학번 INT,
    과목 VARCHAR(50),
    점수 FLOAT
)

PARTITION BY RANGE (학번) (
    PARTITION p0 VALUES LESS THAN (10000),
    PARTITION p1 VALUES LESS THAN (20000),
    PARTITION p2 VALUES LESS THAN (30000),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

위 코드에서는 "Score" 테이블을 생성하면서 "학번(Student)"을 기준으로 수평 파티셔닝을 적용하고 있습니다. `PARTITION BY RANGE (학번)`은 학번을 기준으로 파티션을 구성하겠다는 의미입니다.

그리고 `PARTITION p0 VALUES LESS THAN (10000)`은 학번이 10000보다 작은 데이터를 p0 파티션에 저장하겠다는 의미입니다. 마찬가지로 `PARTITION p1 VALUES LESS THAN (20000)`은 학번이 10000보다 크거나 같고 20000보다 작은 데이터를 p1 파티션에 저장하겠다는 의미입니다. 나머지 파티션들도 동일한 방식으로 구성됩니다. 마지막 파티션은 `MAXVALUE`를 사용하여 학번의 범위에 제한을 두지 않고 나머지 모든 값들을 포함하도록 설정합니다.

위와 같이 파티셔닝 설정을 하면, 학번 범위에 따라 데이터가 자동으로 해당 파티션에 분배되어 저장됩니다. 이를 통해 대용량 데이터 처리나 쿼리 성능 향상을 달성할 수 있습니다.

## Primay Keys and Foreign Keys

Primary Keys를 생성하는 두 가지 방법이 있다.

1. Primary Key 정의
2. Foreign Key + Foreign Key = Composite Key

- 한 학생이 동일한 수업을 중복으로 수강하는 것을 방지합니다. 그러나 문제는 Enrollments와 관련된 또 다른 테이블이 생성될 때 Composite Key가 중복될 수 있다는 점입니다. enrollment_id를 정의하여 (Composite Key가 아닌) 단일한 식별자로 사용함으로써 두 개의 정수를 중복으로 사용하는 대신에 중복을 피하고 관리가 용이해집니다. 그러나 현재 시나리오에서는 별도의 테이블이 필요하지 않기 때문에, Composite Key를 사용하도록 하겠습니다.

Primary Key(기본 키)와 Foreign Key(외래 키)는 데이터베이스에서 관계를 구성하고 식별하기 위해 사용되는 개념입니다. 각각의 정의와 예시를 설명하겠습니다.

1. Primary Key(기본 키):

   - 정의: 기본 키는 테이블에서 각 레코드를 고유하게 식별하는 열(또는 열들)입니다. 기본 키는 중복되지 않고, 비어 있을 수 없으며, 각 레코드에 대해 유일한 값을 가져야 합니다.
   - 예시: "학생(Student)" 테이블에서 "학번(StudentID)" 열을 기본 키로 설정할 수 있습니다. 각 학생은 고유한 학번을 가지며, 학번을 통해 학생을 식별할 수 있습니다.

2. Foreign Key(외래 키):
   - 정의: 외래 키는 한 테이블의 열(또는 열들)로 다른 테이블의 기본 키와 연결된 값입니다. 외래 키를 사용하여 테이블 간의 관계를 형성하고 참조 무결성을 유지할 수 있습니다.
   - 예시: "주문(Order)" 테이블에서 "고객ID(CustomerID)" 열을 외래 키로 설정할 수 있습니다. 이 경우 "고객ID(CustomerID)"는 "고객(Customer)" 테이블의 기본 키인 "고객ID(CustomerID)"와 연결되어 해당 주문이 어떤 고객에게 속하는지를 나타냅니다.

각각의 예시에서, Primary Key는 테이블 내에서 각 레코드를 고유하게 식별하는 역할을 하며, Foreign Key는 테이블 간의 관계를 형성하고 데이터의 일관성과 참조 무결성을 유지하는 데 사용됩니다. Primary Key와 Foreign Key는 데이터베이스 설계에서 중요한 개념으로 활용됩니다.

예시를 통해 Primary Key와 Foreign Key를 자세히 이해하고, 참조 무결성의 개념과 유지 방법을 설명하겠습니다.

예시를 들어보겠습니다. 우리는 "주문(Order)" 테이블과 "고객(Customer)" 테이블을 가지고 있다고 가정해봅시다. "주문(Order)" 테이블은 주문에 대한 정보를 저장하고, "고객(Customer)" 테이블은 고객에 대한 정보를 저장합니다. 이때 "주문(Order)" 테이블의 "고객ID(CustomerID)" 열이 "고객(Customer)" 테이블의 기본 키인 "고객ID(CustomerID)"와 연결된 Foreign Key 역할을 합니다.

- "주문(Order)" 테이블의 일부 레코드:
  주문ID(OrderID) | 주문내용 | 고객ID(CustomerID)

```
  -----------------------------------------
  1               | ...     | 101
  2               | ...     | 102
  3               | ...     | 101
```

- "고객(Customer)" 테이블의 일부 레코드:
  고객ID(CustomerID) | 이름 | 주소

```
  -----------------------------
  101                | John  | New York
  102                | Emily | London
```

위 예시에서 "주문(Order)" 테이블의 "고객ID(CustomerID)" 열은 "고객(Customer)" 테이블의 "고객ID(CustomerID)" 열을 참조하고 있습니다. 이 관계를 통해 각 주문은 어떤 고객에게 속하는지를 나타낼 수 있습니다.

참조 무결성(Referential Integrity)은 Foreign Key와 관련된 개념으로, 데이터베이스에서 데이터의 일관성을 유지하는 데 도움을 줍니다. 참조 무결성은 다음 두 가지 규칙을 포함합니다:

1. Foreign Key 값은 기본 키 값이거나 NULL이어야 합니다.
2. Foreign Key 값은 참조하는 테이블의 기본 키 값과 일치해야 합니다.

참조 무결성을 유지하기 위해서는 다음과 같은 방법을 사용할 수 있습니다:

1. Foreign Key 제약 조건 설정: 데이터베이스 시스템에서 Foreign Key를 정의할 때, 제약 조건을 설정하여 참조 무결성을 강제할 수 있습니다. 이를 통해 Foreign Key 값이 참조하는 테이블의 기본 키와 일치하거나 NULL이어야 한다는 규칙을 적용할 수 있습니다.

2. 관계 유지: 데이터베이스의 관계를 정의할 때 신중하게 설계해야 합니다. 올바른 관계를 설정하고, 데이터의 일관성을 유지하기 위해 Foreign Key 값의 적절한 업데이트와 관리를 해야 합니다.

위 예시에서 참조 무결성은 "주문(Order)" 테이블의 "고객ID(CustomerID)" 값이 "고객(Customer)" 테이블의 "고객ID(CustomerID)" 값과 일치하거나 NULL이어야 한다는 것을 의미합니다. 이를 통해 잘못된 참조나 무효한 데이터가 데이터베이스에 삽입되는 것을 방지할 수 있습니다.

참조 무결성은 데이터의 정확성과 일관성을 유지하기 위해 중요한 요소입니다. 데이터베이스 시스템은 Foreign Key 제약 조건을 검사하여 참조 무결성을 강제하고, 올바른 데이터 관계를 유지하며 데이터의 일관성을 보장합니다.

또 다른 예시는, 유저(User)와 주문(Order) 테이블이 있다고 가정해봅시다. 주문 테이블은 유저 테이블의 기본 키인 외래 키로 유저를 참조합니다. 이때, 가입하지 않은 유저 ID로 주문 테이블에 데이터를 입력하려고 하면 에러가 발생하여 해당 데이터의 삽입을 막습니다. 이로써 주문 테이블 내에서 참조하는 값이 반드시 존재함을 보장할 수 있습니다. 이는 참조하는 테이블의 무결성을 높여줍니다.

- https://velog.io/@destiny1616/Foreign-Key-07mrx6w4
- https://brunch.co.kr/@dan-kim/26

## Foreign Key Constraints

Foreign Key Constraints(외래 키 제약 조건)은 데이터베이스에서 외래 키(Foreign Key)에 적용되는 제약 조건입니다. 이 제약 조건은 데이터의 무결성과 일관성을 유지하고, 참조 무결성을 강제하는 데 사용됩니다.

외래 키 제약 조건은 다음과 같은 특징을 갖습니다:

1. 참조 무결성 유지: 외래 키 제약 조건을 사용하여 데이터베이스는 외래 키의 값이 참조하는 테이블의 기본 키와 일치하거나 NULL이어야 한다는 규칙을 강제합니다. 이를 통해 데이터의 일관성과 정확성을 보장하고, 잘못된 참조나 무효한 데이터의 삽입을 방지합니다.

2. 자동 제약 조건 적용: 외래 키 제약 조건은 데이터베이스 시스템에서 자동으로 적용됩니다. 즉, 외래 키 제약 조건을 설정하면 데이터베이스 시스템은 데이터의 변경 작업(데이터 삽입, 업데이트, 삭제 등)을 수행할 때 제약 조건을 검사하고, 제약 조건을 위반하는 경우 해당 작업을 거부합니다.

3. 제약 조건 유형: 외래 키 제약 조건에는 다양한 유형이 있습니다. 가장 일반적인 유형은 "참조 무결성 제약 조건"으로, 외래 키의 값이 참조하는 테이블의 기본 키와 일치하거나 NULL이어야 함을 의미합니다. 다른 유형으로는 "업데이트 제한"과 "삭제 제한"이 있습니다. 업데이트 제한은 참조되는 테이블의 기본 키 값이 변경되는 것을 방지하며, 삭제 제한은 참조되는 테이블의 기본 키 값이 삭제되는 것을 방지합니다.

4. 제약 조건 설정: 외래 키 제약 조건은 데이터베이스 설계 시 테이블 간의 관계를 정의하는 단계에서 설정됩니다. 데이터베이스 관리 시스템(DBMS)에서 제공하는 문법과 명령을 사용하여 외래 키 제약 조건을 명시적으로 정의할 수 있습니다.

외래 키 제약 조건은 데이터베이스에서 데이터의 일관성과 무결성을 유지하는 데 매우 중요합니다. 이를 통해 데이터베이스는 참조 관계를 정확하게 표현

## Normalization

정규화(Normalization)는 데이터베이스 설계에서 중복을 최소화하고 데이터 일관성을 유지하기 위해 데이터를 구조화하는 프로세스입니다. MySQL과 같은 관계형 데이터베이스 시스템에서 많이 사용됩니다. 정규화를 통해 데이터를 효율적으로 저장하고 질의할 수 있는 데이터베이스 구조를 구축할 수 있습니다.

정규화는 일반적으로 함수적 종속성(Functional Dependency)을 기반으로 합니다. 함수적 종속성은 한 속성의 값을 다른 속성의 값을 결정하는 관계를 나타냅니다. 이를 통해 데이터 중복을 피하고 데이터의 일관성과 무결성을 유지할 수 있습니다.

정규화의 목표는 다음과 같습니다:

1. 제1 정규화(1NF): 데이터를 중복 없이 하나의 값으로 구성하고, 테이블의 모든 속성이 원자값(Atomic Value)을 갖도록 합니다.
2. 제2 정규화(2NF): 부분 함수적 종속성(Partial Functional Dependency)을 제거하여 테이블의 모든 속성이 기본 키에 완전하게 종속되도록 합니다.
3. 제3 정규화(3NF): 이행 함수적 종속성(Transitive Functional Dependency)을 제거하여 테이블의 모든 속성이 기본 키에 직접 종속되도록 합니다.
4. 추가적인 정규화 단계: 필요에 따라 더 높은 정규화 단계를 적용할 수 있습니다. 예를 들어, 제4 정규화(4NF)와 제5 정규화(5NF)는 일부 특수한 경우에 적용될 수 있습니다.

정규화를 통해 데이터를 구조화하면 데이터 중복을 줄이고 데이터의 일관성, 무결성, 효율성을 향상시킬 수 있습니다. 그러나 정규화는 데이터의 일부 성능 저하를 가져올 수도 있으므로, 정규화 수준을 결정할 때는 성능 요구사항과 데이터의 특성을 고려해야 합니다.

정규화를 이해하기 위해 예시를 살펴보겠습니다. 가정해보겠습니다.

우리는 한 회사의 직원 정보를 저장하는 데이터베이스를 설계하려고 합니다. 각 직원에 대한 정보에는 직원 ID, 이름, 부서, 직위, 연봉 등이 포함됩니다. 초기 설계는 다음과 같은 하나의 테이블로 시작할 수 있습니다.

**직원(Employee) 테이블:**

| 직원 ID | 이름  | 부서    | 직위    | 연봉  |
| ------- | ----- | ------- | ------- | ----- |
| 1       | John  | Sales   | Manager | 50000 |
| 2       | Alice | Finance | Analyst | 40000 |
| 3       | Bob   | Sales   | Clerk   | 30000 |

이 테이블은 중복된 데이터를 포함하고 있습니다. 예를 들어, "Sales" 부서의 직원은 "Sales" 부서가 여러 명 있음에도 불구하고 매번 "Sales"를 반복하고 있습니다. 이러한 중복은 데이터를 불필요하게 팽창시키고 일관성을 해칠 수 있습니다.

제1 정규화를 적용하여 이 문제를 해결할 수 있습니다. 제1 정규화는 중복을 제거하고 각 테이블의 모든 속성이 원자값을 갖도록 하는 것을 목표로 합니다. 이를 위해 부서 정보를 별도의 테이블로 분리할 수 있습니다.

**직원(Employee) 테이블:**

| 직원 ID | 이름  | 부서 ID | 직위    | 연봉  |
| ------- | ----- | ------- | ------- | ----- |
| 1       | John  | 1       | Manager | 50000 |
| 2       | Alice | 2       | Analyst | 40000 |
| 3       | Bob   | 1       | Clerk   | 30000 |

**부서(Department) 테이블:**

| 부서 ID | 부서    |
| ------- | ------- |
| 1       | Sales   |
| 2       | Finance |

이제 각 직원의 부서 정보는 부서 테이블의 부서 ID를 참조하는 형태로 저장됩니다. 이로써 부서 정보의 중복이 제거되었습니다.

이 예시에서는 제1 정규화를 적용했지만, 복잡한 데이터베이스에서는 제2 정규화, 제3 정규화 등을 적용하여 데이터를 더욱 효율적으로 구조화할 수 있습니다. 이러한 정규화 단계들은 데이터의 종속성과 관련이 있으며, 데이터베이스 설계의 목적과 요구사항에 따라 적용됩니다.

## 1NF - First Normal Form

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*F01BgH1LHR0sUAvcatTaYw.png" />

MySQL의 1NF(First Normal Form)는 데이터베이스 설계에서 첫 번째 정규화 단계입니다. 1NF를 만족하려면 데이터베이스 테이블의 각 속성은 원자값(Atomic Value)을 가져야 합니다.

즉, 한 테이블의 각 속성은 더 이상 분리되지 않는 최소한의 데이터 조각이어야 합니다. 속성이 원자값이 아니라면, 해당 속성을 분해하여 원자값으로 이루어진 별도의 테이블로 분리해야 합니다.

예를 들어, 다음과 같은 테이블이 있다고 가정해보겠습니다.

**주문(Order) 테이블:**

| 주문 번호 | 고객 이름  | 주문 날짜  | 상품 목록             |
| --------- | ---------- | ---------- | --------------------- |
| 1         | John Doe   | 2021-06-01 | Apple, Banana, Orange |
| 2         | Jane Smith | 2021-06-02 | Mango, Pineapple      |

위의 테이블에서 "상품 목록"은 여러 상품을 쉼표(,)로 구분한 문자열입니다. 이는 여러 값을 포함하고 있으며, 각 상품은 개별적인 정보 단위로 분리되지 않습니다. 따라서 1NF를 만족하지 않습니다.

1NF를 적용하기 위해 "상품 목록"을 분해하여 별도의 테이블을 생성해야 합니다.

**주문(Order) 테이블:**

| 주문 번호 | 고객 이름  | 주문 날짜  |
| --------- | ---------- | ---------- |
| 1         | John Doe   | 2021-06-01 |
| 2         | Jane Smith | 2021-06-02 |

**주문 상품(Order Item) 테이블:**

| 주문 번호 | 상품      |
| --------- | --------- |
| 1         | Apple     |
| 1         | Banana    |
| 1         | Orange    |
| 2         | Mango     |
| 2         | Pineapple |

이렇게 분해된 테이블은 각각의 속성이 원자값을 갖고 있으므로 1NF를 만족합니다. 이를 통해 데이터 중복을 줄이고 질의와 조인을 효율적으로 수행할 수 있게 됩니다.

1NF는 정규화의 첫 번째 단계로, 데이터의 중복을 최소화하고 데이터베이스의 일관성과 무결성을 유지하기 위해 필요한 기본 요구사항입니다.

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*F01BgH1LHR0sUAvcatTaYw.png" />

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*KA1jsyMcNXufNuyqAgJKgQ.png" />

앞서 구성한 courses 테이블에서 태그를 분해하여 별도의 테이블을 생성하는 예시로 설명해드리겠습니다.

**courses 테이블:**

| 수업 ID | 제목         | 태그                     |
| ------- | ------------ | ------------------------ |
| 1       | 데이터베이스 | SQL, 관계형 데이터베이스 |
| 2       | 웹 개발      | HTML, CSS, JavaScript    |
| 3       | 알고리즘     | 자료구조, 정렬 알고리즘  |

위의 테이블에서 "태그" 속성은 여러 태그를 쉼표(,)로 구분한 문자열입니다. 이는 여러 값을 포함하고 있으며, 각 태그는 개별적인 정보 단위로 분리되지 않습니다. 따라서 1NF를 만족하지 않습니다.

1NF를 적용하기 위해 "태그"를 분해하여 별도의 테이블을 생성해야 합니다.

**courses 테이블:**

| 수업 ID | 제목         |
| ------- | ------------ |
| 1       | 데이터베이스 |
| 2       | 웹 개발      |
| 3       | 알고리즘     |

**tags 테이블:**

| 수업 ID | 태그                |
| ------- | ------------------- |
| 1       | SQL                 |
| 1       | 관계형 데이터베이스 |
| 2       | HTML                |
| 2       | CSS                 |
| 2       | JavaScript          |
| 3       | 자료구조            |
| 3       | 정렬 알고리즘       |

이렇게 분해된 테이블은 각각의 속성이 원자값을 갖고 있으므로 1NF를 만족합니다. 이를 통해 데이터 중복을 줄이고 질의와 조인을 효율적으로 수행할 수 있게 됩니다.

1NF는 정규화의 첫 번째 단계로, 데이터의 중복을 최소화하고 데이터베이스의 일관성과 무결성을 유지하기 위해 필요한 기본 요구사항입니다.

## Lock

"lock"은 데이터베이스에서 동시에 여러 트랜잭션이 데이터를 수정하거나 삭제할 때 데이터의 일관성을 유지하기 위해 사용되는 메커니즘입니다.

데이터베이스에서 트랜잭션은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 보장하기 위해 사용됩니다. 동시에 여러 트랜잭션이 동일한 데이터를 수정하거나 삭제할 때 데이터의 일관성을 유지하기 위해 트랜잭션 간의 충돌을 방지하기 위한 제어 메커니즘으로 lock이 사용됩니다.

트랜잭션이 데이터를 수정하거나 삭제하기 위해 데이터베이스에 접근하면, 해당 데이터 또는 데이터의 일부에 대해 lock을 설정합니다. 이 lock은 다른 트랜잭션이 동시에 접근하여 수정하거나 삭제하는 것을 방지합니다. lock은 데이터를 보호하여 동시에 여러 트랜잭션이 동일한 데이터를 동시에 수정하는 것으로 인해 데이터 무결성이 깨지는 것을 방지합니다.

lock은 다양한 레벨과 범위로 설정될 수 있습니다. 예를 들어, 특정 행에 대한 lock(행 레벨 잠금)을 설정할 수도 있고, 전체 테이블에 대한 lock(테이블 레벨 잠금)을 설정할 수도 있습니다. lock의 범위와 레벨은 동시성과 성능의 균형을 유지하기 위해 신중하게 설정되어야 합니다.

lock은 트랜잭션이 완료되거나 롤백되면 해제됩니다. 이를 통해 데이터베이스는 동시성을 제어하면서 일관성을 유지하고, 여러 트랜잭션이 동시에 수정하는 것으로 인한 데이터 충돌을 방지할 수 있습니다.

물론입니다! MySQL에서의 lock을 설명하기 위해 다음 예시를 사용해보겠습니다:

가정해봅시다. 우리는 "Products"라는 테이블을 가지고 있습니다. 이 테이블은 다양한 제품에 대한 정보를 포함하고 있으며, 제품 이름과 수량을 저장합니다.

**Products 테이블:**

| 제품 ID | 제품 이름 | 수량 |
| ------- | --------- | ---- |
| 1       | 사과      | 10   |
| 2       | 바나나    | 15   |
| 3       | 오렌지    | 20   |

이제 두 개의 동시성 트랜잭션(Transaction)인 트랜잭션 A와 트랜잭션 B를 고려해봅시다. 이 두 트랜잭션은 모두 "사과" 제품의 수량을 업데이트하려고 합니다.

**트랜잭션 A:**

```
BEGIN TRANSACTION;
SELECT 수량 FROM Products WHERE 제품 ID = 1;
-- 사과의 수량인 10을 조회

UPDATE Products SET 수량 = 5 WHERE 제품 ID = 1;
-- 사과의 수량을 5로 변경

COMMIT;
```

**트랜잭션 B:**

```
BEGIN TRANSACTION;
SELECT 수량 FROM Products WHERE 제품 ID = 1;
-- 사과의 수량인 10을 조회

UPDATE Products SET 수량 = 8 WHERE 제품 ID = 1;
-- 사과의 수량을 8로 변경

COMMIT;
```

이 상황에서, 두 트랜잭션이 동시에 실행될 때 문제가 발생할 수 있습니다. 만약 트랜잭션 A가 "사과"의 수량을 5로 변경한 후에 트랜잭션 B가 "사과"의 수량을 8로 변경한다면 어떻게 될까요?

MySQL은 이러한 충돌을 방지하기 위해 lock 메커니즘을 사용합니다. 트랜잭션 A가 "사과"에 대한 lock을 설정하고 있는 동안, 트랜잭션 B는 해당 데이터에 접근하여 수정할 수 없습니다. 따라서 트랜잭션 B는 트랜잭션 A가 완료되고 lock이 해제될 때까지 기다려야 합니다.

이를 통해 동시성 문제를 해결하고 데이터의 일관성을 유지할 수 있습니다. MySQL의 lock 메커니즘은 데이터 충돌을 방지하고 트랜잭션 간의 조율을 가능하게 합니다.

## Link Tables

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*KA1jsyMcNXufNuyqAgJKgQ.png" />

MySQL에서 Link Tables(연결 테이블)은 관계형 데이터베이스에서 다대다(N:M) 관계를 처리하기 위해 사용되는 테이블입니다. 다대다 관계는 한 테이블의 레코드가 다른 테이블의 여러 레코드와 관련이 있을 때 발생합니다. Link Tables은 이러한 다대다 관계를 해결하기 위해 중간에 위치하여 두 테이블 간의 연결을 관리합니다.

다음은 Link Tables의 예시를 살펴보겠습니다. 가정해보겠습니다.

우리는 학생(Student)과 과목(Subject) 간의 다대다 관계를 가진 데이터베이스를 설계하려고 합니다. 각 학생은 여러 과목을 수강할 수 있고, 각 과목은 여러 학생이 수강할 수 있습니다.

**학생(Student) 테이블:**

| 학생 ID | 이름  |
| ------- | ----- |
| 1       | John  |
| 2       | Alice |
| 3       | Bob   |

**과목(Subject) 테이블:**

| 과목 ID | 과목명 |
| ------- | ------ |
| 1       | 수학   |
| 2       | 영어   |
| 3       | 과학   |

다대다 관계를 처리하기 위해 Link Table인 수강(Enrollment) 테이블을 생성합니다.

**수강(Enrollment) 테이블:**

| 학생 ID | 과목 ID |
| ------- | ------- |
| 1       | 1       |
| 1       | 2       |
| 2       | 2       |
| 3       | 1       |
| 3       | 3       |

위의 수강 테이블은 학생과 과목 간의 다대다 관계를 관리합니다. 각 행은 학생 ID와 과목 ID의 조합으로 구성되며, 해당 학생이 해당 과목을 수강한다는 관계를 나타냅니다.

이를 통해 한 학생이 여러 과목을 수강하거나 한 과목이 여러 학생에게 수강되는 다대다 관계를 효과적으로 처리할 수 있습니다. Link Table을 사용하여 중복을 제거하고 관계를 명확하게 표현할 수 있습니다.

Link Tables은 다대다 관계를 처리하는 유연하고 효과적인 방법을 제공하며, 데이터베이스의 일관성과 무결성을 유지하는 데 도움을 줍니다.

---

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*KA1jsyMcNXufNuyqAgJKgQ.png" />

수강(Enrollment) 테이블이 아닌 course_tags 테이블을 생성하지 않는다면, courses 테이블에 태그 값을 참조하는 별도의 속성을 생성해야 합니다. 그러나 이는 매번 값이 변경될 때마다 courses 테이블의 여러 속성이 함께 업데이트되어야 하므로 비효율적일 수 있습니다. 또한, 데이터베이스에서 업데이트나 삭제를 수행하는 경우 한 행에 대해 잠금(lock)을 거는데, 이는 동시성과 성능에 문제를 일으킬 수 있습니다.

course_tags 테이블을 생성하여 이러한 문제를 해결할 수 있습니다. course_tags 테이블은 courses 테이블과 tags 테이블 간의 연결을 관리합니다.

예시를 통해 설명드리겠습니다.

**courses 테이블:**

| course_id | course_name  |
| --------- | ------------ |
| 1         | 데이터베이스 |
| 2         | 웹 개발      |
| 3         | 알고리즘     |

**tags 테이블:**

| tag_id | tag_name            |
| ------ | ------------------- |
| 1      | SQL                 |
| 2      | 관계형 데이터베이스 |
| 3      | HTML                |
| 4      | CSS                 |
| 5      | JavaScript          |

**course_tags 테이블:**

| course_id | tag_id |
| --------- | ------ |
| 1         | 1      |
| 1         | 2      |
| 2         | 3      |
| 2         | 4      |
| 2         | 5      |
| 3         | 2      |
| 3         | 5      |

위의 course_tags 테이블은 courses 테이블과 tags 테이블 간의 다대다 관계를 관리합니다. 각 행은 course_id와 tag_id의 조합으로 구성되며, 해당 과목(course)가 해당 태그(tag)와 관련되어 있다는 관계를 나타냅니다.

이렇게 하면 courses 테이블의 다른 속성들과는 별개로 tags 테이블과의 관계를 유지할 수 있습니다. 즉, tags 값이 변경되어도 courses 테이블의 다른 속성은 영향을 받지 않습니다. 또한, 동시성과 성능 문제를 해결하기 위해 각 행에 대한 잠금(lock)을 걸지 않아도 됩니다.

course_tags 테이블을 통해 courses와 tags 간의 다대다 관계를 효율적으로 처리할 수 있으며, 데이터베이스의 일관성과 무결성을 유지할 수 있습니다.
Composite Primary Key라고 부릅니다.

## Candidate Key

후보키(Candidate Key)는 관계형 데이터베이스에서 각 행을 고유하게 식별할 수 있는 속성(또는 속성의 집합)입니다. 후보키는 테이블에서 각 행을 고유하게 식별하고 검색할 수 있도록 도와줍니다.

후보키는 다음과 같은 특징을 갖습니다:

1. 유일성(Uniqueness): 후보키로 선택된 속성의 값은 테이블 내에서 중복되지 않아야 합니다. 즉, 각 행은 후보키 값을 통해 고유하게 식별됩니다.
2. 최소성(Minimality): 후보키로 선택된 속성 집합은 가능한 최소한의 속성으로 구성되어야 합니다. 다시 말해, 후보키에 속한 어떤 속성도 제거할 경우 유일성을 보장할 수 없어야 합니다.

예를 들어, "학생(Student)" 테이블에서 "학번(Student ID)"은 후보키의 예시입니다. 이 속성을 사용하여 각 학생을 고유하게 식별할 수 있으며, 중복되는 값을 가지지 않습니다. 또한, 이 경우에는 다른 속성을 제거할 경우 유일성이 깨지므로 최소성도 충족합니다.

후보키는 단일 속성으로 구성될 수도 있고, 여러 속성의 조합으로 구성될 수도 있습니다. 테이블에는 여러 후보키가 존재할 수 있으며, 주키(Primary Key)는 후보키 중에서 특별한 역할을 수행하는 속성이라고 볼 수 있습니다. 주키는 테이블에서 행을 식별하는 주요 수단으로 사용되며, 보통은 후보키 중에서 선택하여 지정합니다.

## Functional Dependency

완전 함수적 종속(Fully Functional Dependency)과 부분 함수적 종속(Partial Functional Dependency)은 데이터베이스에서 속성들 간의 종속성을 설명하는 개념입니다.

- 완전 함수적 종속(Fully Functional Dependency):
  완전 함수적 종속은 주어진 테이블에서 한 속성이 다른 속성의 모든 가능한 조합에 대해 함수적으로 종속되는 경우를 나타냅니다. 다시 말해, 주어진 테이블에서 속성 A가 속성 B와 C의 조합에 대해 완전하게 종속되는 경우, A는 B와 C의 값을 결정하는 데 있어 독립적이지 않으며, A에 대한 어떠한 변경도 B와 C의 값에 영향을 미칩니다. 이 경우 A는 B와 C에 완전하게 종속되었다고 말합니다.

예를 들어, "학생(Student)" 테이블에서 "학번(Student ID)"은 "이름(Name)"에 대해 완전 함수적으로 종속될 수 있습니다. 즉, 각 학생의 학번은 그 학생의 이름에 종속되며, 학번이 변경되면 이름도 함께 변경되어야 합니다.

- 부분 함수적 종속(Partial Functional Dependency):
  부분 함수적 종속은 주어진 테이블에서 한 속성이 다른 속성의 일부에만 함수적으로 종속되는 경우를 나타냅니다. 다시 말해, 주어진 테이블에서 속성 A가 속성 B와 C 중 일부에만 종속되는 경우, A는 B와 C의 일부 값에만 영향을 받으며, 다른 값에는 영향을 받지 않습니다. 이 경우 A는 B와 C에 부분 함수적으로 종속되었다고 말합니다.

예를 들어, "학생(Student)" 테이블에서 "학번(Student ID)"은 "학과(Department)"에 대해 부분 함수적으로 종속될 수 있습니다. 즉, 학번이 학과에 종속되는데, 학번의 변경이 학과 외의 다른 속성에는 영향을 주지 않습니다.

부분 함수적 종속성은 데이터베이스 설계 중 정규화의 단계에서 문제가 될 수 있으며, 정규화를 통해 이러한 종속성을 제거하고 데이터베이스의 일관성과 무결성을 유지할 수 있습니다.

## 2NF - Second Normal Form

Every column in the table should describe the entity that the table represents.

2NF(Second Normal Form)는 관계형 데이터베이스 설계에서 적용되는 정규화 개념 중 하나입니다. 2NF를 만족하기 위해서는 1NF(First Normal Form)를 이미 만족하고 있어야 합니다.

2NF는 다음과 같은 두 가지 조건을 만족해야 합니다:

1. 테이블의 모든 비주요 속성들이 각각의 후보키(candidate key)에 대해 완전 함수적 종속(Fully Functional Dependent)이어야 합니다.
2. 테이블의 모든 비주요 속성들이 부분 함수적 종속(Partial Functional Dependent)이 아니어야 합니다.

이해를 돕기 위해 예시를 살펴보겠습니다. 아래와 같은 "Students" 테이블을 가정해봅시다:

**Students 테이블:**

| 학번 | 이름 | 학과   | 교수 번호 | 교수 이름 |
| ---- | ---- | ------ | --------- | --------- |
| 101  | John | 컴퓨터 | 1         | Smith     |
| 102  | Jane | 경영   | 1         | Smith     |
| 103  | Alex | 수학   | 2         | Johnson   |

위의 테이블에서 "교수 번호"와 "교수 이름"은 학과에 대한 정보가 아닌 교수에 대한 정보를 나타냅니다. 이 경우, "교수 번호"와 "교수 이름"은 테이블의 후보키가 아니며, "학과"에 대해 부분 함수적 종속을 가지고 있습니다.

이를 2NF로 변환하기 위해 "교수"와 관련된 정보를 별도의 테이블로 분리합니다.

**Professors 테이블:**

| 교수 번호 | 교수 이름 |
| --------- | --------- |
| 1         | Smith     |
| 2         | Johnson   |

**Students 테이블:**

| 학번 | 이름 | 학과   | 교수 번호 |
| ---- | ---- | ------ | --------- |
| 101  | John | 컴퓨터 | 1         |
| 102  | Jane | 경영   | 1         |
| 103  | Alex | 수학   | 2         |

이렇게 분리된 테이블은 "교수 번호"와 "교수 이름"이 후보키에 완전 함수적 종속되어 있고, "학과"에 대한 정보는 부분 함수적 종속을 가지지 않습니다. 따라서 2NF를 만족합니다.

2NF를 적용하면 데이터 중복을 줄이고, 데이터의 일관성과 무결성을 유지하며, 효율적인 질의와 조인이 가능해집니다.

---

Exercise

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*V-_BtBiTxdEsG27DdF3HBQ.png">

다음 사진의 Diagram의 어떤 테이블이 2NF에 위배되는지 파악해주세요.

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*_CejkX-9ntdu3TSy9qBFrg.png" />

Courses 테이블의 instructor 속성은 2NF를 위배하고 있습니다. 왜냐하면 courses 테이블에 있는 instructor 속성은 부분 함수적 종속성을 가지기 때문입니다. 이러한 문제를 해결하기 위해 instructors 테이블을 생성하고, courses 테이블과의 관계를 설정해야 합니다.

## Non-prime attributes

비주요 속성(Non-key Attribute)은 주어진 테이블에서 후보키(Candidate Key)가 아닌 속성을 말합니다. 후보키는 테이블의 레코드를 고유하게 식별하는 역할을 수행하는 하나 또는 여러 개의 속성으로 구성됩니다.

예를 들어, 다음과 같은 테이블을 가정해봅시다:

**학생(Student) 테이블:**

| 학번 | 이름 | 학과        | 주소          |
| ---- | ---- | ----------- | ------------- |
| 101  | John | 컴퓨터 공학 | 서울시 강남구 |
| 102  | Jane | 경영학      | 서울시 강서구 |

위의 테이블에서 "학번"은 후보키이며, "이름", "학과", "주소"는 비주요 속성입니다. 후보키인 "학번"을 통해 각 학생을 고유하게 식별할 수 있지만, "이름", "학과", "주소"는 추가적인 정보를 제공하는 속성으로서 후보키와는 관련성이 적습니다.

비주요 속성은 테이블에서 데이터를 표현하고 설명하는 데 도움을 주는 역할을 합니다. 주요 속성(Primary Attribute)이라고도 불리며, 주로 조회 및 분석 목적으로 사용됩니다. 하지만 비주요 속성은 후보키에 종속되어야 하며, 2NF와 3NF를 준수하도록 데이터베이스를 설계하는 데 중요한 역할을 합니다.

## Transitive Dependency

이행적 종속성(Transitive Dependency)은 관계형 데이터베이스에서 속성 간의 종속성을 나타내는 개념입니다. 어떤 속성 A가 다른 속성 B에 함수적으로 종속되고, 동시에 B가 다른 속성 C에 함수적으로 종속되면, A와 C 간에도 종속성이 발생하는 것을 이행적 종속성이라고 합니다.

간단한 예시를 통해 이해해보겠습니다. 다음과 같은 "학생(Student)" 테이블을 가정해봅시다:

**학생(Student) 테이블:**

| 학번 | 이름 | 학년 | 학과        |
| ---- | ---- | ---- | ----------- |
| 101  | John | 3    | 컴퓨터 공학 |
| 102  | Jane | 2    | 경영학      |
| 103  | Alex | 4    | 수학        |

위의 테이블에서 "학번"은 후보키로서 다른 모든 속성들에 함수적으로 종속됩니다. 하지만 "학과" 속성은 "학년"에 종속되어 있으며, "학년"은 다시 "이름"에 종속되어 있습니다. 이러한 종속성 체인으로 인해 "학번"에서 "이름"으로 이행적 종속성이 발생합니다.

이행적 종속성은 데이터의 중복과 무결성에 영향을 줄 수 있습니다. 정규화를 통해 이러한 종속성을 제거하고, 데이터를 더욱 효율적으로 저장하고 관리할 수 있습니다. 3NF는 이러한 이행적 종속성을 제거하여 데이터의 일관성과 정확성을 보장하는 데 기여합니다.

## 3NF - Third Normal Form

3NF (Third Normal Form)는 관계형 데이터베이스 설계에서 적용되는 정규화 개념 중 하나입니다. 3NF를 만족하기 위해서는 2NF를 이미 만족하고 있어야 합니다.

3NF는 다음과 같은 세 가지 조건을 만족해야 합니다:

1. 테이블의 모든 비주요 속성들이 해당 테이블의 후보키에 대해 이행적으로 종속되지 않아야 합니다.
2. 테이블의 모든 비주요 속성들이 비주요 속성 간에 종속 관계를 갖지 않아야 합니다.
3. 테이블 내에서 이행적 종속성을 갖는 속성들 간의 종속 관계가 제거되어야 합니다.

가정해보겠습니다. "주문 관리(Order Management)" 시스템을 구축하려고 합니다. 주문(Order)과 관련된 정보를 저장하는 데이터베이스를 설계하고자 합니다. 이를 위해 "주문(Order)" 테이블을 생성합니다:

**주문(Order) 테이블:**

| 주문 번호 | 고객 번호 | 고객 이름 | 고객 주소     | 상품 번호 | 상품 이름 | 상품 가격 |
| --------- | --------- | --------- | ------------- | --------- | --------- | --------- |
| 1         | 101       | John      | 서울시 강남구 | 1         | 책        | 20,000    |
| 2         | 102       | Jane      | 서울시 강서구 | 2         | 음악 CD   | 15,000    |
| 3         | 101       | John      | 서울시 강남구 | 3         | 휴대폰    | 500,000   |

위의 테이블에서는 주문 정보와 관련된 모든 정보를 한 테이블에 저장하고 있습니다. 그러나 이 테이블은 3NF를 만족하지 않습니다. 왜냐하면 비주요 속성들이 후보키인 "주문 번호"에 종속되지 않고, 상호간에도 종속 관계가 존재하기 때문입니다.

이를 3NF로 변환하기 위해 테이블을 분해합니다. 분해를 통해 다음과 같은 세 개의 테이블을 생성합니다:

**주문(Order) 테이블:**

| 주문 번호 | 고객 번호 | 상품 번호 |
| --------- | --------- | --------- |
| 1         | 101       | 1         |
| 2         | 102       | 2         |
| 3         | 101       | 3         |

**고객(Customer) 테이블:**

| 고객 번호 | 고객 이름 | 고객 주소     |
| --------- | --------- | ------------- |
| 101       | John      | 서울시 강남구 |
| 102       | Jane      | 서울시 강서구 |

**상품(Product) 테이블:**

| 상품 번호 | 상품 이름 | 상품 가격 |
| --------- | --------- | --------- |
| 1         | 책        | 20,000    |
| 2         | 음악 CD   | 15,000    |
| 3         | 휴대폰    | 500,000   |

이제 각 테이블은 비주요 속성 간에 종속 관계가 없으며, 모든 속성이 후보키에 종속되도록 분

해되었습니다. 이렇게 3NF를 만족시키면 데이터의 중복을 줄이고, 일관성과 무결성을 유지할 수 있습니다. 또한, 데이터를 효율적으로 저장하고 관리할 수 있습니다.

---

위 상태에서 어떻게 관계를 만들 수 있는가요?

분해된 테이블들 간의 관계를 설정하기 위해 외래 키(Foreign Key)를 사용하여 연결합니다. 외래 키는 다른 테이블의 주요 키(primary key)를 참조하는 속성입니다.

위의 예시에서, "주문(Order)" 테이블의 "고객 번호" 속성은 "고객(Customer)" 테이블의 주요 키인 "고객 번호"를 참조해야 합니다. 이를 표현하기 위해 "주문(Order)" 테이블에 "고객 번호"를 외래 키로 추가하고, 이를 "고객(Customer)" 테이블의 주요 키와 연결합니다.

또한, "주문(Order)" 테이블의 "상품 번호" 속성은 "상품(Product)" 테이블의 주요 키인 "상품 번호"를 참조해야 합니다. 마찬가지로 이를 표현하기 위해 "주문(Order)" 테이블에 "상품 번호"를 외래 키로 추가하고, 이를 "상품(Product)" 테이블의 주요 키와 연결합니다.

이렇게 외래 키를 사용하여 테이블 간의 관계를 설정하면, 필요한 정보를 효율적으로 검색하고 데이터의 무결성을 유지할 수 있습니다. 예를 들어, "주문(Order)" 테이블에서 특정 주문의 고객 정보를 조회하거나, "고객(Customer)" 테이블에서 특정 고객의 주문 목록을 조회하는 등의 작업을 수행할 수 있습니다.

---

Foreign Key를 설정하면 3NF 규칙을 깨는 것이 아닌가요?

외래 키(Foreign Key)를 설정하는 것은 3NF 규칙을 깨지 않습니다. 외래 키를 사용하여 테이블 간의 관계를 설정하면 데이터베이스의 일관성과 무결성을 유지할 수 있습니다.

3NF는 데이터베이스의 정규화 과정 중 하나로, 비주요 속성이 후보키에 종속되지 않도록 하는 것을 목표로 합니다. 외래 키는 이러한 종속성을 나타내지 않으며, 다른 테이블의 주요 키를 참조하는 용도로 사용됩니다.

위의 예시에서, "주문(Order)" 테이블의 "고객 번호" 속성과 "상품 번호" 속성은 각각 "고객(Customer)" 테이블의 주요 키와 "상품(Product)" 테이블의 주요 키를 참조하기 위해 외래 키로 설정됩니다. 이를 통해 테이블 간의 관계를 구축하고, 데이터의 일관성과 무결성을 유지할 수 있습니다.

결론적으로, 외래 키 설정은 3NF를 깨지 않으며, 오히려 데이터베이스의 정규화와 일관성을 강화하는데 도움을 줍니다. 외래 키를 올바르게 활용하면 데이터의 일관성과 무결성을 유지하면서 효율적인 데이터 관리를 할 수 있습니다.

## Pragmatic Advice and Don't Model the Universe

정규화 방식은 다양하며 모든 방식을 완벽하게 기억하고 적용하는 것은 쉽지 않을 수 있습니다. 게다가, 일부 시나리오에서는 정규화가 시스템을 더 복잡하게 만들 수 있습니다. 그러므로 정규화는 참고할 수 있는 지침으로 삼아야 하지만, 중복성을 제거하는 데 집중하는 것이 가장 중요합니다. 중복성을 최소화함으로써 데이터 일관성과 효율성을 향상시킬 수 있습니다.

데이터베이스에서 redundancy(중복성)는 동일한 데이터가 여러 곳에 중복되어 저장되는 현상을 가리킵니다. 일반적으로 중복된 데이터를 가지고 있을 때, 데이터베이스의 일관성과 효율성에 부정적인 영향을 미칠 수 있습니다. 여기에 몇 가지 관련된 개념과 이유를 살펴보겠습니다.

1. 데이터 중복:
   중복성은 동일한 데이터가 여러 개의 테이블이나 레코드에 중복되어 저장되는 상황을 의미합니다. 예를 들어, 동일한 고객 정보가 여러 테이블에 저장되는 경우 중복성이 발생할 수 있습니다.

2. 문제점:
   중복성은 데이터베이스에 몇 가지 문제를 초래할 수 있습니다. 첫째, 데이터 일관성을 해칠 수 있습니다. 중복된 데이터의 일부를 업데이트하지 않거나 수정할 경우, 데이터 불일치 문제가 발생할 수 있습니다. 둘째, 중복된 데이터는 저장 공간을 낭비할 수 있습니다. 데이터베이스에서 중복을 최소화함으로써 저장 용량을 줄일 수 있습니다. 셋째, 중복된 데이터를 수정할 때 모든 복사본을 수정해야 하므로 작업의 복잡성이 증가할 수 있습니다.

3. 정규화:
   중복성을 해결하기 위해 정규화(normalization)라는 프로세스를 사용할 수 있습니다. 정규화는 데이터를 효율적으로 구성하고 중복성을 최소화하는 데이터베이스 설계 기법입니다. 정규화는 데이터를 여러 테이블로 분할하여 각 테이블에서 중복을 제거합니다. 이를 통해 데이터 일관성을 향상시키고 저장 공간을 절약할 수 있습니다.

4. 관리:
   데이터베이스 설계 단계에서 중복성을 최소화하는 것이 중요합니다. 중복된 데이터를 줄이기 위해 데이터베이스 정규화 원칙을 준수하고 테이블 간의 관계를 올바르게 설정해야 합니다. 또한 데이터를 업데이트하거나 수정할 때 중복성을 주의하여 모든 관련된 데이터를 일관되게 유지해야 합니다.

중복성은 데이터베이스에서 효율성과 일관성을 저해하는 요소 중 하나입니다. 데이터베이스 설계 시 중복성을 최소화하는 노력을 기울이면 데이터 일관성과 효율성을 향상시킬 수 있습니다.

정규화는 대부분의 경우 데이터베이스 설계를 향상시키지만, 특정 시나리오에서는 비효율적일 수 있습니다. 다음은 정규화가 비효율적으로 작용할 수 있는 예시입니다:

1. 조인 비용 증가:
   정규화된 테이블은 관계를 맺고 조인을 수행해야 합니다. 테이블이 세분화되면 데이터를 검색할 때 조인 연산이 필요하므로 성능에 영향을 미칠 수 있습니다. 특히 데이터의 양이 많거나 복잡한 조인이 필요한 경우에는 조인 비용이 증가하여 성능 저하를 초래할 수 있습니다.

2. 쿼리의 복잡성 증가:
   정규화된 테이블은 여러 개로 분리되기 때문에 데이터를 검색하기 위해 복잡한 쿼리를 작성해야 할 수도 있습니다. 이는 개발자가 쿼리 작성에 더 많은 시간과 노력을 투자해야 함을 의미합니다. 또한 복잡한 쿼리는 유지 보수와 디버깅을 어렵게 만들 수 있습니다.

3. 데이터 일관성 유지 어려움:
   정규화된 테이블은 데이터를 여러 개의 테이블에 분산시키기 때문에 데이터 일관성을 유지하기가 어려울 수 있습니다. 여러 테이블에 걸쳐 업데이트가 필요한 경우, 모든 테이블을 동시에 업데이트해야 하므로 일관성 유지가 복잡해집니다.

4. 성능 저하:
   정규화를 과도하게 적용하면 테이블 간의 관계가 복잡해질 수 있습니다. 이는 쿼리 실행 계획을 어렵게 만들어 성능 저하를 초래할 수 있습니다. 특히 조인이 많이 필요한 경우 성능에 영향을 미칠 수 있습니다.

정규화는 일반적으로 데이터베이스 설계의 중요한 원칙이지만, 항상 적용해야 하는 것은 아닙니다. 설계 목적과 요구 사항을 고려하여 정규화를 적절하게 적용하는 것이 중요합니다.

---

**Don't Model the Universe**

- Simplicity is the Ultimate Sophistication
- Solve today's problems, not future problems that may never happen.
- Build a model for your problem domain, not the real world.
- Don't make an assumption: what if this happens?
- Don't be proud for designing a complex model, you can be proud only if you can take a complex model and simplify it.
- Changes will happen whether you predict them or not, no matter how much experiences you have you're never gonna to be able to predict all future requirements.

"Don't model the universe"는 MySQL과 관련된 데이터베이스 설계 및 모델링 원칙 중 하나입니다. 이 원칙은 데이터베이스를 설계할 때 현실 세계의 모든 개념과 엔티티를 완벽하게 모델링하지 말라는 의미를 가지고 있습니다.

주된 이유는 현실 세계는 복잡하며 다양한 관계와 상호작용으로 이루어져 있기 때문입니다. 이를 모두 정확하게 반영하려고 하면 데이터베이스 모델이 지나치게 복잡해지고 유지 관리가 어려워질 수 있습니다. 또한, 현실 세계의 모든 세부 사항을 데이터베이스에 반영하는 것은 효율성과 성능에도 부정적인 영향을 미칠 수 있습니다.

대신, "Don't model the universe" 원칙은 중요한 비즈니스 요구사항과 데이터 관계에 집중하여 필요한 부분만 모델링하라는 의미를 내포하고 있습니다. 데이터베이스 설계 시 필요한 개념과 엔티티를 잘 정의하고 구조화하여 중요한 비즈니스 프로세스를 지원하고 데이터 일관성을 유지할 수 있도록 해야 합니다.

이러한 원칙은 데이터베이스 설계의 가독성, 유지 보수성, 성능, 확장성 등을 향상시키는 데 도움을 줄 수 있습니다. 데이터베이스 모델을 간결하고 명확하게 유지하면 개발자와 데이터베이스 관리자가 데이터베이스를 이해하고 조작하기 쉬워지며, 애플리케이션의 성능도 향상될 수 있습니다.

따라서 "Don't model the universe" 원칙은 데이터베이스 설계 시 현실 세계의 복잡성을 최소화하고 핵심적인 요구사항에 초점을 맞추어 간결하고 효율적인 데이터 모델을 구축하는 것을 장려합니다.

## Forward Engineering a Model

Forward Engineering은 소프트웨어 공학에서 사용되는 용어로, 시스템 또는 소프트웨어 모델의 설계를 실제 구현으로 전환하는 과정을 말합니다. Forward Engineering은 모델링 도구나 개발 환경을 사용하여 설계된 모델을 소스 코드, 데이터베이스 스키마, 인터페이스 등의 구체적인 구현 요소로 변환하는 단계입니다.

주로 다음과 같은 단계로 진행됩니다:

1. 모델링: 시스템 또는 소프트웨어의 설계를 수행합니다. 이 단계에서는 요구사항을 분석하고 클래스 다이어그램, 데이터베이스 스키마, 시퀀스 다이어그램 등의 모델링 도구를 사용하여 설계 모델을 작성합니다.

2. 구현: 모델을 기반으로 실제 소스 코드, 데이터베이스 스키마, 인터페이스 등을 개발합니다. 이 단계에서는 프로그래밍 언어, 데이터베이스 관리 시스템, 개발 도구 등을 사용하여 모델을 구현합니다.

3. 코드 생성: 모델링 도구나 개발 환경에서는 주로 자동 코드 생성 기능을 제공합니다. 이 기능을 사용하여 설계 모델에서 소스 코드를 생성하거나 데이터베이스 스키마를 자동으로 생성할 수 있습니다. 코드 생성은 개발자의 생산성을 향상시키고 일관성 있는 구현을 제공하기 위한 도구입니다.

4. 테스트 및 디버깅: 구현된 시스템이나 소프트웨어를 테스트하고 버그를 수정하는 단계입니다. 이 단계에서는 단위 테스트, 통합 테스트, 시스템 테스트 등을 수행하여 개발된 코드의 정확성과 기능적인 동작을 확인합니다.

Forward Engineering은 모델링 단계에서 시작하여 실제 구현을 위한 소스 코드와 관련 구성 요소를 생성하고 개발하는 과정입니다. 이 과정은 소프트웨어 개발의 생명 주기에서 중요한 부분을 차지하며, 모델과 구현 사이의 일관성과 정확성을 유지하기 위해 중요한 역할을 합니다.

---

MySQL

1. Database Menu
2. Forward Engineering
3. Local Instance

## Synchronizing a Model with a Database

MySQL에서 모델을 데이터베이스와 동기화하는 방법에는 여러 가지가 있습니다. 가장 흔히 사용되는 방법은 MySQL Workbench를 사용하여 모델을 생성하고 변경 사항을 데이터베이스에 적용하는 것입니다. 다음은 일반적으로 따르는 프로세스입니다:

1. MySQL Workbench에서 모델 생성: MySQL Workbench를 열고 새로운 모델을 생성하거나 기존 모델을 엽니다. 테이블, 관계, 인덱스 등과 같은 데이터베이스 개체를 모델에 추가하고 설정합니다. 모델은 시각적인 도구를 사용하여 데이터베이스 스키마를 시각적으로 표현하는 데 사용됩니다.

2. 변경 사항 적용: 모델에서 변경 사항이 있을 때, 변경 사항을 데이터베이스에 적용해야 합니다. 이를 위해 MySQL Workbench의 "Forward Engineer" 기능을 사용합니다. 이 기능은 모델과 데이터베이스 간의 차이를 비교하고 변경 사항을 자동으로 생성하여 데이터베이스에 적용합니다.

   - "Forward Engineer" 기능 실행: MySQL Workbench에서 "Database" 메뉴로 이동하고 "Forward Engineer" 옵션을 선택합니다.
   - 연결 설정: 데이터베이스에 연결하기 위한 필요한 정보(호스트, 포트, 사용자 이름, 암호 등)를 입력합니다.
   - 변경 사항 선택: 적용할 변경 사항을 선택합니다. 이는 모델과 데이터베이스 간의 차이를 기반으로 생성됩니다. 생성될 SQL 스크립트에는 테이블 생성, 수정, 삭제, 인덱스 생성 등의 작업이 포함될 수 있습니다.
   - 변경 사항 검토: 생성된 SQL 스크립트를 검토하고 변경 사항이 올바른지 확인합니다.
   - 변경 사항 적용: 변경 사항을 데이터베이스에 적용합니다. 이를 위해 "Apply" 버튼을 클릭하고 변경 사항을 수락합니다.

3. 동기화 확인: 변경 사항이 데이터베이스에 적용되면 해당 데이터베이스와 모델이 동기화됩니다. 변경된 테이블, 관계, 인덱스 등이 데이터베이스에 반영되어 데이터베이스 스키마가 모델과 일치하는지 확인할 수 있습니다.

MySQL Workbench를 사용하여 모델과 데이터베이스를 동기화하는 것은 변경 사항을 관리하고 일관성을 유지하는 데 도움이 됩니다. 이를 통해 모델링 단계와 실제 데이터베이스 간의 일관성을 유지하고, 변경 사항을 효율적으로 관리할 수 있습니다.

## Reverse Engineering a Database

Reverse Engineering은 소프트웨어 공학에서 사용되는 용어로, 이미 존재하는 시스템이나 데이터베이스의 구현을 분석하여 해당 구현을 기반으로 모델을 생성하는 과정을 말합니다. Reverse Engineering은 주로 다음과 같은 경우에 활용됩니다:

1. 기존 시스템의 문서화: 이미 개발된 시스템이나 데이터베이스에 문서화가 부족한 경우, Reverse Engineering을 통해 해당 시스템의 구조와 요소를 분석하여 문서를 작성할 수 있습니다. 이를 통해 시스템을 이해하고 유지보수, 개선, 재설계를 위한 기반을 마련할 수 있습니다.

2. 레거시 시스템 분석: 레거시 시스템이나 유지보수가 어려운 시스템의 구현을 분석하여 해당 시스템을 이해하는 데 활용할 수 있습니다. Reverse Engineering을 통해 시스템의 구조와 흐름, 데이터베이스 스키마 등을 파악하여 문제를 해결하거나 개선할 수 있습니다.

3. 새로운 시스템 개발: 이미 구현된 시스템이나 데이터베이스를 기반으로 새로운 시스템을 개발할 때 Reverse Engineering을 활용할 수 있습니다. 기존 시스템의 구현을 분석하여 요구사항을 파악하고 새로운 시스템의 모델링이나 설계에 활용할 수 있습니다.

Reverse Engineering을 수행하기 위해서는 주로 다음과 같은 절차를 따릅니다:

1. 데이터베이스 분석: 분석 대상인 데이터베이스를 확인하고 해당 데이터베이스의 구조, 테이블, 관계, 인덱스, 제약조건 등을 파악합니다.

2. 스키마 추출: 데이터베이스에서 스키마 정보를 추출합니다. 이를 통해 테이블, 컬럼, 관계 등을 분석할 수 있습니다.

3. 코드 분석: 필요한 경우 데이터베이스와 연결된 코드를 분석하여 시스템의 동작 원리와 비즈니스 로직을 이해합니다.

4. 모델 생성: 분석한 데이터베이스 구조와 코드를 기반으로 모델을 생성합니다. 이를 위해 모델링 도구나 개발 환경을 사용할 수 있습니다. 생성된 모델은 시각적인 도구를 사용하여 시스템의 구조를 표현하는 데 사용됩니다.

Reverse Engineering은 기존 시스템을 분석하고 이해하기 위한 중요한 과정으로, 시스템을 유지보수하거나 개선하는 데 도움을 줍니다.
