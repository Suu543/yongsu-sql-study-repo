# Indexing

`Indexing`은 데이터베이스에서 검색 속도를 향상시키기 위해 사용되는 기술입니다. 인덱스는 데이터베이스 테이블의 하나 이상의 열에 대한 정렬된 데이터 구조로, 해당 열의 값을 빠르게 검색하고 효율적으로 데이터에 접근할 수 있도록 돕습니다. 인덱스는 특정 열의 값을 사전 순서로 정렬하고 해당 값과 연결된 레코드의 위치를 유지합니다.

인덱스는 다음과 같은 목적을 가지고 사용됩니다:

1. **검색 성능 개선**: 인덱스는 데이터베이스에서 특정 값을 검색할 때 필요한 시간을 줄여줍니다. 인덱스를 사용하면 데이터베이스가 테이블을 순차적으로 검색하는 대신 인덱스를 통해 빠르게 원하는 데이터를 찾을 수 있습니다. 특히 대량의 데이터가 있는 테이블에서 검색 속도의 차이는 상당히 큽니다.

2. **정렬 개선**: 인덱스는 데이터베이스 테이블의 열을 정렬된 상태로 유지합니다. 따라서 특정 열을 기준으로 정렬된 결과를 빠르게 얻을 수 있습니다. 정렬된 데이터를 사용하는 작업이 많은 경우 인덱스를 사용하면 작업의 성능이 향상될 수 있습니다.

3. **유일성 보장**: 인덱스를 사용하면 특정 열에 대해 유일한 값을 갖도록 설정할 수 있습니다. 이를 통해 데이터의 무결성을 유지하고 중복된 값을 방지할 수 있습니다.

인덱스를 사용하는 것은 검색 속도를 향상시키고 데이터베이스의 성능을 개선하는 중요한 방법 중 하나입니다. 그러나 인덱스는 데이터베이스의 공간을 차지하고 인덱스를 업데이트하는 데 일정한 비용이 발생할 수 있으므로, 적절한 열과 상황에 맞게 인덱스를 생성하는 것이 중요합니다. 데이터베이스의 특성과 사용 패턴을 고려하여 인덱스를 설계하고 관리하는 것이 좋습니다.

전화번호부를 비유로 사용하여 데이터베이스 인덱싱을 설명하겠습니다.

상상해보세요, 매우 큰 규모의 전화번호부가 있다고 가정해봅시다. 이 전화번호부에는 수천 개의 이름과 전화번호가 기록되어 있습니다. 이 전화번호부를 사용하여 특정 사람의 전화번호를 찾는다고 가정해봅시다.

인덱싱이 없는 경우, 전화번호부를 처음부터 끝까지 순서대로 검색해야 합니다. 모든 페이지를 돌면서 원하는 사람의 이름을 찾아야 하므로 검색에 많은 시간이 소요됩니다. 이는 매우 비효율적이며, 전화번호부의 크기가 커질수록 검색 시간이 증가합니다.

하지만 이제 인덱싱을 도입해보겠습니다. 전화번호부의 알파벳 순으로 정렬된 색인 페이지를 만듭니다. 이 색인 페이지에는 각 알파벳 범주(예: A, B, C...)와 해당 범주 내에서의 이름의 시작점을 가리키는 링크가 포함됩니다.

이제 검색을 할 때, 우리는 먼저 색인 페이지에서 원하는 이름의 알파벳 범주를 찾습니다. 예를 들어 "Smith"를 찾고 싶다면 "S"의 범주를 찾을 것입니다. 그런 다음 해당 범주에서 "Smith"를 찾는 데 필요한 페이지로 이동합니다.

이렇게 함으로써, 인덱싱을 통해 우리는 전체 전화번호부를 검색하지 않고도 원하는 이름을 빠르게 찾을 수 있습니다. 인덱스는 데이터베이스에서 특정 값(예: 이름)을 검색할 때 필요한 페이지를 빠르게 찾을 수 있도록 도와줍니다.

인덱싱을 사용하면 데이터베이스에서도 마찬가지로 원하는 값을 빠르게 검색할 수 있습니다. 인덱스는 데이터베이스 내의 열에 대한 정렬된 데이터 구조로, 해당 값과 연결된 레코드의 위치를 유지합니다. 이를 통해 데이터베이스에서 원하는 데이터를 효율적으로 검색할 수 있고, 검색 성능을 향상시킬 수 있습니다.

---

<img src="https://cdn-images-1.medium.com/max/800/1*Wbx9kz2btpKuw3LQwvkoSw.png" />
<img src="https://cdn-images-1.medium.com/max/800/1*jfNEJ4R5PR9MZPg4JzmhEg.png" />
<img src="https://cdn-images-1.medium.com/max/800/1*PkHZlDi-oU2QcSSyVdu25A.png" />
<img src="https://cdn-images-1.medium.com/max/800/1*83bS0SbsY2t30yZEUoyg1w.png" />

인덱싱이 없는 상태에서는 4개의 데이터가 특정 데이터와 일치하는지 파악하는 데 큰 문제가 없을 수 있습니다. 그러나 만약 1만 개의 데이터 중에서 "CA"라는 값을 찾아야 한다면, 최악의 경우 1만 번을 비교하여 분석해야하는 많은 시간과 비효율이 발생할 수 있습니다.

이러한 경우에는 인덱싱을 사용하여 문제를 해결하고 성능을 향상시킬 수 있습니다. 인덱스를 생성하면 데이터베이스에서 "CA"와 일치하는 값을 빠르게 찾을 수 있습니다. 인덱스는 데이터베이스의 열을 정렬된 상태로 유지하고, 해당 값과 연결된 레코드의 위치를 유지합니다. 따라서 인덱스를 사용하면 "CA"와 일치하는 값을 검색하기 위해 전체 데이터를 순차적으로 비교할 필요 없이 인덱스를 참조하여 빠르게 결과를 얻을 수 있습니다.

인덱싱을 이용하면 데이터베이스에서 원하는 데이터를 효율적으로 검색할 수 있고, 검색 성능을 향상시킬 수 있습니다. 특히 데이터의 크기가 커질수록 인덱싱의 중요성은 더 커집니다. 인덱싱은 데이터베이스의 성능을 개선하고 데이터에 빠르게 접근할 수 있도록 도와줍니다.

인덱스를 디스크가 아닌 메모리에 저장하는 기술을 "인메모리 인덱싱(In-Memory Indexing)"이라고 합니다. 인메모리 인덱싱은 데이터베이스의 인덱스를 주 메모리(RAM)에 저장하여 빠른 데이터 액세스와 처리를 가능하게 합니다.

일반적으로 디스크는 메모리에 비해 접근 속도가 느리지만, 메모리는 접근 속도가 매우 빠릅니다. 따라서 데이터베이스에서 인덱스를 메모리에 저장하면 디스크를 사용하는 경우보다 훨씬 빠른 데이터 검색이 가능해집니다.

인메모리 인덱싱의 주요 장점은 다음과 같습니다:

1. **빠른 검색 및 조회 성능**: 메모리에 인덱스를 저장하므로 디스크 액세스에 비해 매우 빠른 검색 및 조회 속도를 제공합니다. 데이터베이스에서 원하는 데이터를 실시간으로 검색하거나 조회할 때 매우 유용합니다.

2. **응답 시간 최소화**: 메모리에 데이터를 보관하기 때문에 데이터베이스에서 쿼리를 실행하는 동안 발생하는 디스크 I/O의 부담을 최소화합니다. 이는 응답 시간을 크게 단축시켜 사용자 경험을 향상시킵니다.

3. **실시간 분석 및 처리**: 메모리에 데이터를 보유하므로 실시간 분석이나 복잡한 연산 작업을 빠르게 처리할 수 있습니다. 대용량 데이터셋의 빠른 집계, 정렬, 그룹화 등의 작업을 가능케 합니다.

인메모리 인덱싱은 데이터베이스 시스템이 메모리 요구사항을 충족할 수 있는 환경에서 가장 효과적으로 작동합니다. 메모리의 용량과 데이터베이스 크기, 사용 패턴 등을 고려하여 인메모리 인덱싱의 적절한 활용 여부를 평가해야 합니다.

---

인덱싱은 데이터베이스에서 검색 성능을 향상시키지만, 인덱스를 생성하고 유지하는 데에는 일정한 비용이 발생합니다. 이를 "인덱싱 비용(Cost of Indexing)"이라고 합니다.

인덱싱 비용은 다음과 같은 측면에서 발생할 수 있습니다:

1. **저장 공간 비용**: 인덱스는 데이터베이스의 추가적인 저장 공간을 필요로 합니다. 인덱스는 데이터의 복사본이 아니라 해당 값과 연결된 위치 정보를 유지하기 위한 데이터 구조이지만, 큰 데이터베이스에서는 인덱스가 상당한 용량을 차지할 수 있습니다. 따라서 인덱스를 생성할 때는 저장 공간 비용을 고려해야 합니다.

2. **업데이트 비용**: 데이터베이스에서 인덱스를 유지하기 위해서는 데이터의 삽입, 갱신, 삭제 작업이 발생할 때마다 인덱스도 업데이트되어야 합니다. 이는 추가적인 작업과 시간이 소요되는 비용을 의미합니다. 데이터의 변경이 자주 발생하는 경우, 인덱스 업데이트가 많아져 성능에 영향을 미칠 수 있습니다.

3. **쿼리 최적화 비용**: 인덱스를 생성하면 데이터베이스 시스템은 쿼리 실행 계획을 최적화하는 과정에서 인덱스를 고려해야 합니다. 인덱스를 이용한 쿼리 최적화는 추가적인 계산 비용이 발생하며, 이를 위해 데이터베이스 엔진은 인덱스 통계 정보를 유지하고 인덱스 선택 기준을 적용합니다.

4. **메모리 비용**: 인덱스를 메모리에 유지하기 위해서는 메모리 용량이 필요합니다. 큰 인덱스를 메모리에 모두 로드하는 경우에는 메모리 용량의 한계가 있을 수 있으며, 이는 추가적인 메모리 비용을 초래할 수 있습니다.

인덱싱 비용은 인덱스의 크기, 업데이트 빈도, 쿼리 패턴 등 여러 요인에 따라 다를 수 있습니다. 데이터베이스 설계와 운영 시 인덱싱 비용을 고려하여 적절한 인덱스를 생성하고 관리하는 것이 중요합니다. 데이터베이스의 크기, 성능 요구 사항, 업데이트 빈도 등을 고려하여 인덱스를 사용할지 말지 결정하고, 필요한 경우 인덱스의 성능을 모니터링하며 최적화하는 것이 좋습니다.

---

**Reserve indexes for performance critical queries**

"Reserve indexes for performance critical queries"는 인덱스를 성능이 중요한 쿼리에 대해서만 사용하라는 의미입니다.

인덱스는 데이터베이스에서 데이터를 검색하고 조회하는 속도를 향상시키는 도구입니다. 그러나 인덱스는 추가적인 저장 공간과 업데이트 비용을 요구하기 때문에 모든 열에 인덱스를 생성하는 것은 권장되지 않습니다.

"Reserve indexes for performance critical queries"는 성능이 중요한 쿼리에만 인덱스를 사용하라는 원칙을 강조합니다. 일반적으로 다음과 같은 상황에서 인덱스를 사용하는 것이 좋습니다:

1. **자주 실행되는 쿼리**: 자주 실행되는 쿼리에 대해서는 인덱스를 생성하여 검색 속도를 향상시킬 수 있습니다. 쿼리의 실행 빈도가 높은 열에 인덱스를 생성하는 것이 좋습니다.

2. **대량의 데이터를 검색하는 쿼리**: 대량의 데이터를 검색하는 쿼리는 인덱스 없이는 성능 저하가 발생할 수 있습니다. 이러한 쿼리에 대해서는 필터링 또는 정렬에 사용되는 열에 인덱스를 생성하여 효율적인 데이터 검색을 도모할 수 있습니다.

3. **조인 연산을 수행하는 쿼리**: 조인 연산은 대체로 성능에 민감한 작업입니다. 조인에 사용되는 열에 인덱스를 생성하면 조인 연산의 성능을 향상시킬 수 있습니다.

4. **정렬이나 그룹화를 필요로 하는 쿼리**: 정렬이나 그룹화를 수행하는 쿼리에 대해서도 인덱스를 생성하여 성능을 향상시킬 수 있습니다.

"Reserve indexes for performance critical queries"는 인덱스를 적절하게 사용하여 성능이 중요한 쿼리에 집중하는 것을 권장합니다. 인덱스를 최적화하고 관리함으로써 데이터베이스의 전반적인 성능을 향상시킬 수 있습니다.

---

**Design indexes based on your queries, not table**

일반적으로 인덱싱은 이진 트리(Binary Tree)로 구현되지만, 이 수업에서는 개념을 이해하기 쉽게 하기 위해 테이블 형태로 구현했습니다.

"Design indexes based on your queries, not table"은 데이터베이스 인덱스를 설계할 때 테이블이 아닌 쿼리를 기반으로 인덱스를 설계해야 한다는 의미입니다.

일반적으로 데이터베이스에는 다양한 종류의 쿼리가 존재합니다. 각 쿼리는 특정한 조건에 따라 데이터를 검색하거나 조작하는 데 사용됩니다. 이러한 쿼리들은 특정한 열 또는 조합된 열들에 대해 필터링, 정렬, 그룹화, 조인 등을 수행할 수 있습니다.

"Design indexes based on your queries, not table"은 이러한 쿼리들을 고려하여 인덱스를 설계하는 것이 중요하다는 의미입니다. 각각의 쿼리는 특정한 데이터에 대한 접근 방식과 필요한 데이터의 패턴을 가지고 있습니다. 따라서 인덱스를 설계할 때는 어떤 쿼리가 자주 실행되는지, 어떤 열 또는 열의 조합이 자주 사용되는지 등을 고려해야 합니다.

올바른 인덱스 설계를 위해서는 다음과 같은 접근 방식을 고려할 수 있습니다:

1. **자주 실행되는 쿼리 식별**: 어떤 쿼리가 자주 실행되는지를 파악합니다. 자주 실행되는 쿼리에 대해 인덱스를 생성하면 해당 쿼리의 성능을 향상시킬 수 있습니다.

2. **필터링 및 정렬에 사용되는 열 식별**: 어떤 열이 필터링이나 정렬에 자주 사용되는지를 확인합니다. 이러한 열에 대해 인덱스를 생성하면 검색 성능을 향상시킬 수 있습니다.

3. **조인에 사용되는 열 식별**: 어떤 열이 조인 연산에서 자주 사용되는지를 확인합니다. 조인에 사용되는 열에 대해 인덱스를 생성하면 조인 연산의 성능을 향상시킬 수 있습니다.

4. **다중 열 인덱스 고려**: 여러 열의 조합에 대한 인덱스도 고려해야 합니다. 쿼리에서 여러 열의 조합이 자주 사용되는 경우, 해당 열들에 대한 다중 열 인덱스를 생성하여 성능을 최적화할 수 있습니다.

요약하면, "Design indexes based on your queries, not table"은 데이터베이스 인덱스를 설계할 때 테이블 자체보다는 실제로 실행되는 쿼리를 기반으로

인덱스를 설계해야 한다는 원칙을 강조합니다. 이를 통해 쿼리의 실행 성능을 최적화하고 데이터베이스의 전반적인 성능을 향상시킬 수 있습니다.

## Clustered Index vs Non-Clustered Index

**Clustered Index**: 테이블의 데이터가 실제로 디스크에 저장되는 순서와 인덱스의 순서가 일치.

- MySQL에서 Clustered Index(클러스터드 인덱스)는 데이터베이스 테이블에서 레코드를 물리적으로 정렬하는 인덱스 구조입니다. 클러스터드 인덱스를 사용하면 테이블의 데이터가 실제로 디스크에 저장되는 순서와 인덱스의 순서가 일치하게 됩니다. 이는 테이블의 데이터를 읽을 때 디스크 상에서 연속된 블록으로 읽을 수 있어서 데이터에 대한 검색과 쿼리 실행 성능을 향상시키는데 도움이 됩니다.

**Clustered Index(클러스터드 인덱스)의 특징**:

1. 한 테이블당 하나의 클러스터드 인덱스만 생성할 수 있습니다.

2. 클러스터드 인덱스를 정의하면 테이블의 물리적 순서가 인덱스의 기준에 따라 재정렬됩니다.

3. 클러스터드 인덱스의 기준은 주로 자주 사용되는 검색 조건으로 선택하는 것이 좋습니다.

4. 클러스터드 인덱스는 자주 갱신되는 테이블에서는 성능 이슈가 발생할 수 있으므로 신중하게 선택해야 합니다.

**Clustered Index(클러스터드 인덱스)의 장점**:

1. 데이터베이스의 검색 성능이 향상됩니다. 인덱스 순서와 데이터의 물리적 순서가 일치하기 때문에 디스크에서 연속된 블록으로 데이터를 읽을 수 있습니다.
2. 클러스터드 인덱스는 자주 사용되는 검색 조건에 대해 매우 빠른 응답 속도를 제공합니다.
3. 범위 검색(Range Scan)에 대해서도 빠른 성능을 제공합니다.

**Clustered Index(클러스터드 인덱스)의 단점**:

1. 클러스터드 인덱스의 정렬 순서를 변경하거나 기준을 바꾸는 작업은 비용이 많이 듭니다.
2. 테이블에 자주 데이터가 갱신되는 경우 클러스터드 인덱스 재구성에 따른 오버헤드가 발생할 수 있습니다.
3. 자주 갱신되는 컬럼을 기준으로 클러스터드 인덱스를 생성하는 경우, 인덱스 재조정이 빈번하게 발생하여 성능 저하가 있을 수 있습니다.

클러스터드 인덱스는 주로 자주 검색되는 컬럼이나 자주 사용되는 쿼리의 기준 컬럼을 기준으로 생성하는 것이 좋습니다. 그러나 테이블의 특성과 사용 패턴에 따라 비클러스터드 인덱스를 조합하여 최적의 성능을 얻을 수도 있습니다. 데이터베이스 설계 시에 테이블과 인덱스의 구조를 잘 고려하여 성능을 최적화하는 것이 중요합니다.

---

**Non-Clustered Index**: 인덱스와 실제 데이터의 물리적 순서가 다를 수 있으며, 이 경우 데이터를 찾기 위해서는 인덱스를 참조한 후 해당 레코드를 읽어야 함.

- 다른 비클러스터드 인덱스(Non-Clustered Index)는 인덱스와 실제 데이터의 물리적 순서가 다를 수 있으며, 이 경우 데이터를 찾기 위해서는 인덱스를 참조한 후 해당 레코드를 읽어야 합니다. 하지만 클러스터드 인덱스는 인덱스 자체가 데이터의 물리적 순서를 반영하기 때문에 인덱스를 통해 원하는 레코드를 직접 읽을 수 있습니다.

### Physical order or Physical sequence (물리적 순서)

물리적 순서는 데이터가 디스크에 저장되는 실제 순서를 의미합니다. 데이터베이스 테이블은 디스크 상에 여러 데이터 블록으로 분할되어 저장되는데, 이러한 블록들은 디스크의 특정 위치에 할당됩니다. 물리적 순서는 이러한 블록들이 디스크 상에 어떤 순서로 배치되는지를 나타냅니다.

클러스터드 인덱스를 사용하면 데이터베이스 테이블의 데이터가 클러스터드 인덱스의 기준에 따라 물리적으로 정렬됩니다. 예를 들어, 클러스터드 인덱스를 생성할 때 테이블의 특정 컬럼을 기준으로 정렬한다고 가정해 봅시다. 그렇다면 이 컬럼의 값들을 오름차순 또는 내림차순으로 정렬하여 디스크 상에 연속된 블록에 저장하게 됩니다.

이렇게 데이터의 물리적 순서가 인덱스의 순서와 일치하는 것은 데이터베이스 관리 시스템이 데이터를 검색할 때 더 효율적인 방법을 제공합니다. 인덱스를 사용하여 특정 값을 검색하거나 범위 검색을 수행할 때, 데이터베이스는 물리적으로 연속된 블록을 읽을 수 있으므로 디스크 접근 횟수를 줄일 수 있습니다. 이로 인해 검색 성능이 향상됩니다.

반면, 클러스터드 인덱스가 아닌 비클러스터드 인덱스의 경우, 인덱스와 데이터의 물리적 순서가 일치하지 않을 수 있습니다. 따라서 인덱스를 사용하여 데이터를 검색할 때에는 먼저 인덱스를 참조한 후 해당 레코드를 실제로 읽어야 하므로, 더 많은 디스크 접근이 필요할 수 있습니다. 이로 인해 일부 검색 성능이 감소할 수 있습니다.

따라서 데이터베이스의 성능을 최적화하기 위해 인덱스를 설계할 때는 클러스터드 인덱스와 비클러스터드 인덱스의 특성을 고려하여 적절한 인덱스를 선택하고 구성하는 것이 중요합니다.

## How do SQL Indexes Work

MySQL에서는 InnoDB 스토리지 엔진을 사용할 때, 기본적으로 기본 키(Primary Key)가 정의된 열에 대해 클러스터드 인덱스가 자동으로 생성됩니다. 즉, InnoDB 테이블을 생성할 때 기본 키를 지정하면 해당 기본 키가 클러스터드 인덱스로 사용됩니다.

클러스터드 인덱스는 테이블의 레코드를 물리적으로 정렬하는 인덱스이므로, 테이블의 데이터를 기본 키를 기준으로 정렬하여 저장하게 됩니다. 이로 인해 데이터 검색과 쿼리 실행 성능이 향상됩니다.

예를 들어, 아래와 같이 테이블을 생성하면 EmployeeId 열에 대한 클러스터드 인덱스가 자동으로 생성됩니다.

```sql
CREATE TABLE Employee (
    EmployeeId INT PRIMARY KEY,
    Name VARCHAR(50),
    Department VARCHAR(50),
    -- 추가 컬럼들
) ENGINE=InnoDB;
```

위의 예제에서 `EmployeeId` 열이 기본 키로 지정되었기 때문에 해당 열에 대한 클러스터드 인덱스가 생성됩니다. 만약 다른 열을 기본 키로 지정하고 싶다면, 해당 열에 대해 `PRIMARY KEY` 제약 조건을 지정하면 됩니다. 그러면 그 열이 클러스터드 인덱스로 사용됩니다.

<img src="https://cdn-images-1.medium.com/max/800/0*v1F1nHKdTtTA-67l.jpg" />

<br />

EmployeeId가 기본 키이므로 기본적으로 EmployeeId 열에 클러스터드 인덱스가 생성됩니다. 이것은 직원 데이터가 EmployeeId 열의 값에 따라 정렬되어 일련의 데이터 페이지에 물리적으로 저장되는 트리와 유사한 구조를 갖습니다.

<img src="https://cdn-images-1.medium.com/max/800/0*iCsAlN5kC0zCAIjd.png" />

- 트리의 가장 아래에 있는 노드는 데이터 페이지 또는 리프 노드(data pages or leaf nodes)라고 불리며, 실제 데이터 행을 포함하고 있습니다.

- EmployeeId가 기본 키이며, 기본적으로 이 열에 클러스터드 인덱스가 생성되므로 이러한 직원 행은 EmployeeId 열을 기준으로 정렬됩니다.

- 예를 들어, Employee 테이블에 1200개의 행이 있고, 각 데이터 페이지에는 200개의 행이 들어있다고 가정합니다.

- 첫 번째 데이터 페이지에는 1번부터 200번까지의 행이, 두 번째 페이지에는 201번부터 400번까지의 행이 있습니다. 이와 같이 계속됩니다.

- 트리의 맨 위에 있는 노드를 루트 노드(Root Node)라고 합니다.

- 루트 노드(Root Node)와 리프 노드(Leaf Node) 사이의 노드를 중간 레벨(intermediate levels)이라고 합니다.

- 루트 및 중간 레벨 노드에는 인덱스 행이 포함됩니다.

- 각 인덱스 행에는 키 값(EmployeeId)가 B-트리의 중간 레벨 페이지 또는 리프 노드의 데이터 행에 대한 포인터가 들어 있습니다.이렇게 데이터 행을 신속하게 찾을 수 있도록 쿼리 엔진이 도와주는 일련의 포인터가 이 트리와 유사한 구조에 포함되어 있습니다.

## How SQL finds a row by ID

<img src="https://cdn-images-1.medium.com/max/800/0*WKzHtv2TablwWl3L.jpg" />

예를 들어 EmployeeId = 1120인 Employee 행을 찾고 있다고 가정합니다.

1. 데이터베이스 엔진은 루트 노드(Root Node)에서 시작하고 오른쪽에 있는 인덱스 노드를 선택합니다. 데이터베이스 엔진은 801 ~ 1200까지의 EmployeeId를 포함하는 노드임을 파악하고 있기 때문입니다.

2. 1001부터 1200까지의 직원 데이터 행이 이 리프 노드(Leaf Node)에 존재하므로, 여기서 오른쪽 끝에 있는 리프 노드(Leaf Node)를 선택합니다.

3. 리프 노드(Leaf Node)의 데이터 행은 EmployeeId로 정렬되므로 데이터베이스 엔진은 EmployeeId = 1120인 행을 쉽게 찾을 수 있습니다.

- 단 3개의 작업에서 SQL은 목적한 데이터를 찾을 수 있습니다. 표에 있는 클러스터된 인덱스를 사용하고 있습니다.

<img src="https://cdn-images-1.medium.com/max/800/0*keCMH3IfCWIQ28sq.png" />

<br />

1. SQL 서버는 이름 열(Name Column)에서 비클러스터 인덱스를 사용해 직원 항목을 빠르게 찾습니다.
2. 비클러스터 인덱스는 직원 이름(Employee Name)과 클러스터 키(EmployeeId)로 구성됩니다.
3. 데이터베이스 엔진은 EmployeeId에 클러스터된 인덱스가 있음을 알고 있으므로, 클러스터된 인덱스를 사용하여 해당 직원 레코드를 찾습니다.

## Non-Clustered Index in SQL

<img src="https://cdn-images-1.medium.com/max/800/0*b4ebaM39Kkm09BFk.png" />

- 비클러스터 인덱스(Non-clustered index)에는 테이블 데이터 대신, 키 값과 행 로케이터가 존재합니다 (Key values and row locators).

- 이름 열(Name Column)에 비클러스터 인덱스를 생성하고, 이 경우 키 값은 알파벳 순서로 정렬되고 저장됩니다.

- 트리 하단의 행 로케이터(Row Locator)에는 해당 행의 직원 이름(Employee Names)과 클러스터 키가 포함됩니다. 위 사진에는 EmployeeId가 클러스터 키입니다.

---

`Clustered Row Locator`

데이터베이스에서 클러스터드 인덱스와 Row Locator의 관계를 예시를 통해 설명해보겠습니다.

예시를 위해, 다음과 같은 Employee 테이블을 가정합니다.

| EmployeeId | Name  | Department |
| ---------- | ----- | ---------- |
| 101        | John  | HR         |
| 102        | Alice | Marketing  |
| 103        | Bob   | Sales      |
| ...        | ...   | ...        |

1. 클러스터드 인덱스 생성: `EmployeeId` 열을 기준으로 클러스터드 인덱스를 생성합니다. 이로 인해 EmployeeId에 따라 데이터가 물리적으로 정렬됩니다.

2. Row Locator의 역할: 클러스터드 인덱스를 사용하여 데이터를 검색할 때, Row Locator가 데이터 레코드의 물리적인 위치를 식별하는 역할을 수행합니다. 예를 들어, EmployeeId가 102인 직원의 데이터를 검색하고자 한다면, 인덱스를 탐색하여 해당 데이터 레코드를 식별합니다.

3. Row Locator의 값: MySQL의 InnoDB 스토리지 엔진에서 Row Locator를 "Clustered Index Record"라고 부르며, 이는 기본 키 값과 일치하는 데이터 레코드의 주소를 가리키는 값입니다. 따라서, EmployeeId가 102인 경우, "Clustered Index Record"는 EmployeeId가 102인 데이터 레코드의 물리적인 주소를 가리키게 됩니다.

4. 데이터 레코드 위치 식별: 클러스터드 인덱스를 사용하여 EmployeeId가 102인 데이터를 찾을 때, Row Locator를 통해 해당 데이터 레코드의 물리적인 위치를 식별합니다. 이로 인해 데이터베이스는 해당 데이터 레코드를 효율적으로 읽어오게 됩니다.

이렇게 클러스터드 인덱스와 Row Locator의 조합은 데이터베이스의 테이블 데이터를 효율적으로 저장하고 검색하는 데에 큰 도움을 줍니다. 특히, 대량의 데이터를 처리하는 경우, 클러스터드 인덱스와 Row Locator를 사용하여 데이터베이스의 성능을 향상시킬 수 있습니다.

---

`Non-Clustered Row Locator`

비클러스터드 인덱스와 Row Locator의 관계를 예시를 통해 설명해보겠습니다.

예시를 위해, 다음과 같은 Employee 테이블을 가정합니다.

| EmployeeId | Name  | Department |
| ---------- | ----- | ---------- |
| 101        | John  | HR         |
| 102        | Alice | Marketing  |
| 103        | Bob   | Sales      |
| ...        | ...   | ...        |

1. 비클러스터드 인덱스 생성: `Department` 열을 기준으로 비클러스터드 인덱스를 생성합니다. 이로 인해 Department에 따라 데이터가 논리적으로 정렬됩니다.

2. 비클러스터드 인덱스 동작: 비클러스터드 인덱스는 인덱스 노드와 실제 데이터 레코드가 서로 다른 순서로 저장되는데, 이 때 각 인덱스 노드는 해당 데이터 레코드를 가리키는 포인터를 갖고 있습니다.

3. Row Locator의 역할: 비클러스터드 인덱스를 사용하여 데이터를 검색할 때, Row Locator가 각 인덱스 노드와 해당 데이터 레코드의 물리적인 위치를 식별하는 역할을 수행합니다.

4. Row Locator의 값: MySQL의 InnoDB 스토리지 엔진에서도 비클러스터드 인덱스에 대해 Row Locator가 사용됩니다. 비클러스터드 인덱스의 Row Locator는 인덱스 노드와 해당 데이터 레코드의 물리적인 주소를 가리키는 값입니다.

5. 데이터 레코드 위치 식별: 비클러스터드 인덱스를 사용하여 Department가 'Marketing'인 데이터를 찾을 때, Row Locator를 통해 해당 데이터 레코드의 물리적인 위치를 식별합니다. 이로 인해 데이터베이스는 해당 데이터 레코드를 효율적으로 읽어오게 됩니다.

비클러스터드 인덱스와 Row Locator의 조합은 데이터베이스에서 특정 열을 기준으로 데이터를 논리적으로 정렬하고 검색할 수 있도록 도와줍니다. 이를 활용하여 다양한 쿼리를 빠르고 효율적으로 처리할 수 있습니다.

## Creating Indexes

먼저 첨부한 파일을 실행해 1,000명의 고객을 추가합니다.

```sql
SELECT customer_id FROM customers;

EXPLAIN SELECT customer_id FROM customers

SELECT COUNT(*) FROM customers;

-- Before Index
EXPLAIN SELECT customer_id FROM customers WHERE state = "CA";

CREATE INDEX idx_state ON customers (state);

-- After Index
EXPLAIN SELECT customer_id FROM customers WHERE state = "CA";
```

위의 코드는 MySQL에서 쿼리 실행 계획을 확인하기 위해 사용되는 "EXPLAIN" 문과 함께 특정 조건을 충족하는 고객의 customer_id를 검색하는 SELECT 문입니다.

EXPLAIN 문은 쿼리의 실행 계획을 보여주는 도구로, 데이터베이스 시스템이 쿼리를 실행하는 방식과 사용되는 인덱스, 테이블 간의 조인 방법 등을 보여줍니다. 이를 통해 쿼리의 성능을 분석하고 최적화할 수 있는 정보를 제공합니다.

SELECT 문은 customers 테이블에서 state 열이 "CA"인 고객의 customer_id를 검색하는 쿼리입니다. 이 쿼리는 "WHERE state = 'CA'" 조건을 사용하여 특정한 상태(state)가 'CA'인 고객을 필터링합니다.

인덱스는 데이터베이스에서 효율적인 검색을 위해 사용되는 기술로, 데이터베이스 내의 특정 컬럼(열)에 대한 색인을 생성하는 것을 말합니다. 위 문장에서 언급된 상황에서는 CA(특정 지역)에 사는 사람을 쿼리하기 위해서 총 고객 숫자인 1011명을 검토해야합니다. 이때, 데이터베이스 테이블에 적절한 인덱스를 생성하는 것이 중요한 이유가 있습니다.

인덱스를 사용하지 않는다면, 데이터베이스가 모든 1011명의 고객 정보를 순차적으로 탐색해야합니다. 이는 데이터베이스에 대량의 데이터가 있는 경우 많은 시간과 자원을 소모하게 되며, 쿼리 실행 성능이 저하될 수 있습니다. 쿼리의 실행 시간이 오래 걸리면 사용자 경험이 나빠지고, 서비스의 성능이 저하되는 결과를 초래할 수 있습니다.

반면, 인덱스를 사용하면 데이터베이스는 인덱스를 통해 빠르게 원하는 데이터를 찾아낼 수 있습니다. 즉, 데이터베이스 엔진은 인덱스를 이용하여 더 적은 시간에 원하는 결과를 가져올 수 있으며, 검색 작업이 효율적으로 이루어집니다. 인덱스를 사용하면 데이터베이스 성능이 향상되고, 쿼리 실행 시간이 단축되어 사용자에게 더 빠른 응답을 제공할 수 있습니다.

따라서, 데이터베이스에서 쿼리 성능을 최적화하고 효율적인 검색을 위해서는 적절한 컬럼에 인덱스를 생성하는 것이 좋습니다. 특히 대량의 데이터를 다루는 상황에서는 인덱스를 사용하는 것이 필수적이며, 데이터베이스 성능 향상과 원활한 서비스 제공에 큰 도움이 됩니다.

위의 코드를 실행할 때 EXPLAIN 문을 사용하면 MySQL은 쿼리 실행 계획을 생성하고 출력합니다. 이 계획은 쿼리가 실행될 때 데이터베이스가 어떻게 작업을 수행하는지를 보여줍니다. 예를 들어, 어떤 인덱스가 사용되는지, 어떤 테이블이 조인되는지, 데이터를 어떤 순서로 액세스하는지 등을 확인할 수 있습니다.

실행 결과로 나오는 쿼리 실행 계획은 효율적인 쿼리 실행을 위해 최적화를 수행할 때 유용한 정보를 제공합니다. 예를 들어, 인덱스가 사용되지 않거나 효율적인 인덱스가 없는 경우 성능 저하가 발생할 수 있으며, 이를 개선하기 위해 인덱스를 생성할 수 있습니다.

요약하면, 위의 코드는 EXPLAIN 문과 SELECT 문을 결합하여 특정 조건을 충족하는 고객의 customer_id를 검색하고, 쿼리 실행 계획을 확인하여 쿼리의 성능을 분석하고 최적화하는 데 사용됩니다. 이를 통해 데이터베이스 성능을 향상시키고, 대량의 데이터를 더 효율적으로 처리하여 원활한 서비스를 제공할 수 있습니다.

MySQL에서 인덱스를 생성하는 방법은 다음과 같습니다:

1. 기본적인 인덱스 생성 구문:

   ```
   CREATE INDEX index_name ON table_name (column_name);
   ```

   위의 구문에서 `index_name`은 생성할 인덱스의 이름을 나타내며, `table_name`은 인덱스를 생성할 테이블의 이름입니다. `column_name`은 인덱스를 생성할 열의 이름입니다. 이 구문을 사용하여 특정 열에 인덱스를 생성할 수 있습니다.

2. 유니크 인덱스 생성:

   ```
   CREATE UNIQUE INDEX index_name ON table_name (column_name);
   ```

   위의 구문은 유니크 인덱스를 생성하는 방법입니다. 유니크 인덱스는 중복 값을 허용하지 않는 인덱스입니다. 테이블에서 중복된 값을 가지는 열에 유니크 인덱스를 생성할 수 있습니다.

3. 다중 열 인덱스 생성:

   ```
   CREATE INDEX index_name ON table_name (column1, column2, ...);
   ```

   다중 열 인덱스는 여러 열의 조합에 대해 인덱스를 생성하는 방법입니다. 여러 열이 함께 사용되는 쿼리에서 성능을 향상시키는 데 유용합니다.

4. 외래 키 인덱스 생성:
   외래 키를 사용하는 경우에는 외래 키 열에 인덱스를 생성하는 것이 좋습니다. 외래 키를 사용하여 두 테이블 간의 관계를 정의하고 검색 및 조인 성능을 향상시킬 수 있습니다.

인덱스를 생성할 때 몇 가지 주의해야 할 점이 있습니다:

- 인덱스는 데이터베이스의 저장 공간을 차지하므로 필요한 경우에만 인덱스를 생성하는 것이 좋습니다. 필요하지 않은 인덱스를 생성하면 데이터베이스 성능이 저하될 수 있습니다.
- 인덱스를 생성할 열은 자주 검색되는 열이나 필터링, 정렬, 조인 등에 사용되는 열을 선택하는 것이 좋습니다.
- 인덱스의 이름은 고유하게 지정하는 것이 좋습니다.

인덱스는 데이터베이스 성능을 향상시키는 강력한 도구이지만, 적절하게 사용해야 합니다. 필요한 쿼리에 대해 올바른 열에 인덱스를 생성하고, 인덱스의 유지 관리와 업데이트를 주기적으로 수행하는 것이 좋습니다.

---

**practice**

```sql
-- Write a query to find customers with more than 1,000 points
SELECT customer_id
FROM customers
WHERE points > 1000;

EXPLAIN
SELECT customer_id
FROM customers
WHERE points > 1000;

CREATE INDEX idx_points ON customers (points);

EXPLAIN
SELECT customer_id
FROM customers
WHERE points > 1000;
```

## Viewing Indexes

```sql
SHOW INDEXES IN customers;
```

MySQL에서 인덱스를 확인하는 방법은 다음과 같습니다:

1. `SHOW INDEX` 문 사용하기:

```sql
SHOW INDEX FROM 테이블명;
SHOW INDEXES IN 테이블명;
```

MySQL에서 두 개의 구문인 `SHOW INDEX FROM 테이블명;`와 `SHOW INDEXES IN 테이블명;`의 차이점은 없습니다. 두 구문은 동일한 결과를 반환합니다.

MySQL에서 `SHOW INDEX FROM`과 `SHOW INDEXES IN`은 같은 목적으로 사용되는 동의어입니다. 테이블의 인덱스 정보를 조회하고, 해당 테이블의 인덱스 목록과 각 인덱스의 세부 정보를 보여주는 역할을 합니다.

따라서, 두 구문 중 어떤 것을 사용하더라도 `customers` 테이블의 인덱스 정보를 동일하게 얻을 수 있습니다. 어떤 구문을 사용할지는 개인적인 선호나 스타일에 따라 선택하면 됩니다. 일관성을 유지하기 위해 한 가지 구문을 선택해 사용하는 것이 좋습니다. 예를 들어 `SHOW INDEXES IN customers;`를 사용하거나 `SHOW INDEX FROM customers;`를 사용해도 됩니다.

위의 쿼리를 실행하면 특정 테이블에 대한 인덱스 정보를 조회할 수 있습니다. 결과로는 인덱스의 이름, 칼럼, 고유 여부, 칼럼 순서 등이 표시됩니다.

---

MySQL에서 `SHOW INDEX FROM customers;` 또는 `SHOW INDEXES IN customers;`를 호출한 결과 중 `key_name`이 `PRIMARY`인 것은 클러스터형 인덱스(클러스터드 인덱스)입니다.

클러스터형 인덱스는 데이터를 물리적으로 테이블과 함께 저장하는 인덱스 유형입니다. InnoDB 스토리지 엔진에서 주 키(primary key)를 기준으로 클러스터형 인덱스를 생성합니다. 따라서 `key_name`이 `PRIMARY`인 항목은 해당 테이블의 주 키(primary key)에 대한 클러스터형 인덱스를 나타냅니다 (자동으로 생성되고, 한 테이블에 최대 한 개만 가질 수 있습니다).

클러스터형 인덱스를 사용하면 주 키에 대한 레코드들이 물리적으로 인접해 저장되기 때문에 주 키를 사용한 검색과 함께 데이터 쿼리가 더 빠르게 수행될 수 있습니다. 그러나 한 테이블당 하나의 클러스터형 인덱스만 가질 수 있기 때문에 주의해서 사용해야 합니다.

만약 해당 테이블에 `PRIMARY`이라는 이름의 인덱스가 있으면, 그것이 클러스터형 인덱스일 것입니다. 그러나 아래와 같이 특정 테이블의 클러스터형 인덱스를 확인하려면, `key_name`이 `PRIMARY`인지 뿐만 아니라 `Non_unique` 항목이 `0`인지도 확인해야 합니다.

예시 출력:

```
Table: customers
Non_unique  Key_name   Seq_in_index  Column_name  ...
   0        PRIMARY        1         customer_id  ...
   1        email_unique   1         email        ...
```

위와 같이 `Non_unique`가 `0`이면서 `key_name`이 `PRIMARY`인 경우 해당 테이블은 주 키를 기준으로 클러스터형 인덱스를 가지고 있다고 볼 수 있습니다.

---

MySQL에서 `SHOW INDEX FROM customers;` 또는 `SHOW INDEXES IN customers;` 구문을 호출하여 출력되는 결과 중 `Collation` 컬럼은 인덱스의 정렬 순서를 나타냅니다. 인덱스가 어떤 정렬 순서로 데이터를 정렬하는지를 지정하는 역할을 합니다. `Collation`에 나타날 수 있는 값으로 `A`와 `B`가 의미하는 내용은 다음과 같습니다:

1. `A`: 오름차순 (Ascending)

- 데이터가 작은 값부터 큰 값으로 정렬됩니다. 예를 들어, 숫자의 경우 1, 2, 3, ...과 같이 작은 값부터 큰 값으로 정렬됩니다.

2. `B`: 내림차순 (Descending)

- 데이터가 큰 값부터 작은 값으로 정렬됩니다. 예를 들어, 숫자의 경우 10, 9, 8, ...과 같이 큰 값부터 작은 값으로 정렬됩니다.

MySQL에서는 여러 다른 언어와 문자 집합을 지원하므로, `Collation` 값은 각 언어 및 문자열 집합에 따라 다양합니다. `A`와 `B`는 정렬 방식을 표현하는 데에만 사용되는 일반적인 표기 방식입니다. 실제로 사용되는 Collation 값은 예를 들어 `utf8_general_ci`, `utf8mb4_unicode_ci`, `latin1_swedish_ci` 등과 같이 더 복잡한 문자열일 수 있습니다.

예시 출력:

```
Table: customers
Non_unique  Key_name   Seq_in_index  Column_name  Collation  ...
   0        PRIMARY        1         customer_id  A          ...
   1        email_unique   1         email        A          ...
```

위와 같이 `Collation` 값이 `A`인 경우, 해당 인덱스는 오름차순으로 데이터를 정렬합니다. `B`인 경우, 내림차순으로 데이터를 정렬합니다. 하지만 일반적으로 주로 사용되는 인덱스는 `A`인 오름차순 정렬입니다.

---

MySQL에서 `SHOW INDEX FROM customers;` 또는 `SHOW INDEXES IN customers;` 구문을 호출하여 출력되는 결과 중 `Cardinality` 컬럼은 인덱스의 고유한 값의 수를 나타내는 지표입니다. 즉, 해당 인덱스가 얼마나 다양한 고유한 값으로 데이터를 구분하는지를 알려줍니다.

`Cardinality` 값이 높을수록 인덱스가 더 많은 다른 값으로 구분되고 있으며, 쿼리 성능 개선에 도움이 됩니다. 고유한 값의 수가 많을수록 인덱스를 사용하여 특정 값을 검색하는 작업이 더 빨라집니다. 반면에 `Cardinality` 값이 낮을 경우, 인덱스를 사용하여 검색하더라도 많은 행이 선택되는 것이므로 성능이 저하될 수 있습니다.

예시 출력:

```
Table: customers
Non_unique  Key_name   Seq_in_index  Column_name  Collation  Cardinality  ...
   0        PRIMARY        1         customer_id  A          1000         ...
   1        email_unique   1         email        A          800          ...
```

위와 같이 `Cardinality` 값이 `1000`인 경우, `customer_id` 인덱스는 1000개의 고유한 값이 있음을 의미합니다. 이는 `customer_id` 인덱스가 1000개의 다른 고객을 식별하고 있다는 것을 나타냅니다.

`Cardinality` 값은 인덱스의 통계 정보를 기반으로 계산되며, 데이터의 분포와 인덱스의 선택이 얼마나 효과적인지를 판단하는데 도움을 줍니다. 따라서 쿼리 성능을 개선하거나 인덱스를 최적화하는 데에 유용한 지표 중 하나입니다.

---

```sql
ANALYZE TABLE customers;
SHOW INDEXES IN customers;
```

`ANALYZE TABLE customers;`은 MySQL에서 테이블의 인덱스 통계 정보를 갱신하는 명령입니다. 이 명령은 데이터베이스 관리 시스템이 최적의 실행 계획을 선택하는데 도움을 주기 위해 사용됩니다.

인덱스는 데이터베이스의 성능에 큰 영향을 미치며, 쿼리의 실행 속도를 높이기 위해서는 인덱스가 최적화되어야 합니다. `ANALYZE TABLE` 명령을 실행하면 MySQL은 해당 테이블의 인덱스 통계 정보를 다시 계산하고 업데이트합니다. 이 통계 정보는 인덱스가 어떤 데이터 분포를 가지고 있는지, 인덱스의 카디널리티 등을 포함합니다.

주로 데이터의 분포가 변경되거나 인덱스가 추가/수정/삭제된 경우에 `ANALYZE TABLE` 명령을 사용하여 통계 정보를 갱신합니다. 이렇게 하면 데이터베이스 엔진이 더 효율적으로 쿼리를 실행할 수 있으며, 쿼리 성능을 향상시킬 수 있습니다.

참고로, `ANALYZE TABLE`은 InnoDB 스토리지 엔진에서만 사용 가능한 명령이며, MyISAM 엔진에서는 사용할 수 없습니다. 또한, 최신 버전의 MySQL에서는 일부 엔진에서 자동으로 통계 정보를 업데이트하기 때문에 직접적으로 실행할 필요가 없을 수도 있습니다.

---

`Secondary indexes`와 `non-clustered indexes`는 개념적으로 비슷하지만, 엄밀하게 말하면 서로 다른 용어입니다. 이 용어들은 다른 데이터베이스 관리 시스템(DBMS)에서 사용되는 경우가 있으며, 다른 맥락에서 더 정확하게 사용될 수 있습니다.

1. Secondary Indexes (보조 인덱스):

- "Secondary indexes"는 일반적으로 다른 인덱스와 함께 사용되는 인덱스를 의미합니다. 주로 "primary index" 또는 "clustered index"와 대조하여 사용됩니다. "Primary index"는 테이블의 물리적 순서를 결정하는 인덱스이며, 그 테이블에 하나만 존재합니다. "Secondary indexes"는 이러한 "primary index" 이외의 추가적인 인덱스로, 테이블의 물리적 순서를 결정하지 않습니다. "Secondary indexes"는 일반적으로 검색과 정렬의 성능을 향상시키는 데 사용됩니다.

2. Non-clustered Indexes (비 클러스터형 인덱스):

- "Non-clustered indexes"는 테이블의 레코드와 실제 데이터를 물리적으로 분리하여 저장하는 인덱스를 의미합니다. 테이블에 여러 개의 "non-clustered indexes"가 존재할 수 있습니다. 각 "non-clustered index"는 인덱스 키와 해당 키가 가리키는 실제 데이터의 주소를 포함합니다. 즉, "non-clustered index"는 데이터베이스의 물리적 저장 순서와 관계없이 인덱스 키를 기반으로 빠른 검색을 제공합니다. 많은 RDBMS에서 "non-clustered indexes"는 테이블의 기본적인 인덱스 유형으로 사용됩니다.

따라서, 두 용어는 일반적으로 비슷한 개념을 가리키지만, 데이터베이스 관리 시스템에 따라 사용되는 용어의 정확한 의미가 달라질 수 있습니다. MySQL에서는 주로 "secondary indexes"를 사용하는 것이 일반적이며, "non-clustered indexes"라는 용어보다는 "secondary indexes"라는 용어를 더 많이 사용합니다.

```sql
SHOW INDEXES IN customers;
```

위 쿼리 실행시 두 번째와 세 번째 위치한 열의 `column_name` 부분에 `state`와 `points`가 입력된 것을 확인할 수 있습니다. 이는 내부적으로 각각의 `column_name`에 해당하는 값들과 기본적으로 `customer_id` 값이 함께 포함되어 인덱스 테이블이 형성됩니다.

---

```sql
SHOW INDEXES IN orders;
```

위 쿼리를 실행하면 네 개의 인덱스 값이 존재하는 것을 확인할 수 있습니다. 이는 데이터베이스가 외래키를 기반으로 내부적으로 인덱스를 자동으로 생성하기 때문입니다. 이러한 인덱스는 이후 관계가 형성된 테이블끼리 조인 쿼리를 실행할 때 성능을 높이는 데 사용됩니다.

## Prefix Indexes

Prefix Indexes(접두어 인덱스)는 인덱스를 생성할 때 인덱스로 선택한 컬럼의 앞 부분 일부만 인덱싱하는 기술을 말합니다. 이렇게 부분적으로 인덱싱하는 것은 전체 컬럼을 인덱스로 사용하는 것보다 일부만 인덱싱하여 인덱스 크기를 줄이는 효과가 있습니다. Prefix Indexes를 사용하는 이유는 다음과 같습니다:

1. 인덱스 크기 감소: String Columns(문자열 컬럼)인 CHAR, VARCHAR, TEXT, BLOB 등은 문자열 길이에 따라 저장 공간이 크게 차지할 수 있습니다. 이러한 컬럼들의 전체 내용을 인덱스로 사용하는 것은 큰 인덱스를 생성하게 되어 메모리 및 디스크 공간 낭비를 초래할 수 있습니다. 따라서, Prefix Indexes를 사용하여 일부만 인덱싱하면 인덱스의 크기를 줄여 저장 공간을 절약할 수 있습니다.

2. 성능 향상: 인덱스를 사용하여 데이터를 검색할 때, 인덱스의 크기가 작을수록 인덱스를 메모리에 더 빠르게 적재할 수 있습니다. 이는 데이터베이스 엔진이 인덱스를 더 효율적으로 활용하여 쿼리의 실행 속도를 향상시킵니다. Prefix Indexes를 사용하면 작은 크기의 인덱스를 생성하여 더 빠른 데이터 검색을 가능케 합니다.

그러나 Prefix Indexes를 사용할 때 주의해야 할 점도 있습니다. 인덱스의 접두어를 사용하면 일부만 인덱싱하므로, 데이터를 검색할 때 정확한 일치 여부를 확인하는 데 제약이 생길 수 있습니다. 인덱스의 접두어 길이가 너무 짧으면 일치하지 않는 데이터도 결과로 반환될 수 있으므로, 적절한 접두어 길이를 선택하는 것이 중요합니다. 이는 데이터의 특성과 조회 쿼리의 필요성에 따라 결정되어야 합니다.

결론적으로, Prefix Indexes는 String Columns의 크기가 큰 경우 인덱스의 크기를 감소시켜 성능을 향상시키는 데 도움이 됩니다. 하지만 접두어 길이를 적절하게 선택해야하며, 데이터의 무결성을 유지하면서 쿼리의 성능을 최적화하는 것이 중요합니다. 데이터베이스의 크기와 성능 요구사항을 고려하여 적절한 인덱스 전략을 선택하는 것이 데이터베이스 성능 최적화에 도움이 됩니다.

접두사 인덱스를 생성하려면 `CREATE INDEX` 문을 사용하고, 인덱스 칼럼에 일부 문자열 길이를 지정하면 됩니다. 예를 들어, 칼럼 `name`의 첫 3개 문자만을 인덱싱하려면 다음과 같이 작성할 수 있습니다:

```sql
CREATE INDEX idx_name ON 테이블명 (name(3));
```

위의 예제에서는 `name` 칼럼의 첫 3개 문자만을 인덱싱하도록 설정한 것입니다. 이렇게 생성된 인덱스는 `name` 칼럼의 첫 3개 문자로 시작하는 값들에 대한 검색에 사용될 수 있습니다.

MySQL에서 접두사 인덱스를 사용하면 인덱스 크기를 줄이고 일부 검색 작업의 성능을 향상시킬 수 있습니다. 그러나 인덱스의 선택도에 대해 신중하게 고려해야 하며, 적절한 칼럼 부분을 선택하여 인덱스를 생성해야 합니다.

---

비효율적인 접두사(또는 prefix) 인덱스와 효율적인 접두사 인덱스에 대한 예시를 알려드리겠습니다.

비효율적인 접두사 인덱스의 예시:
가령, "users" 테이블에 있는 "name" 칼럼에 대한 접두사 인덱스를 생성한다고 가정해봅시다. 하지만, 대다수의 이름이 길지 않고 유일성이 높은 경우에는 접두사 인덱스가 효과적이지 않을 수 있습니다. 예를 들어, "John", "Jane", "Jim"과 같은 이름들은 인덱스를 사용하는 대신 전체 테이블 스캔이 더 효율적일 수 있습니다.

효율적인 접두사 인덱스의 예시:
하지만, 접두사 인덱스는 일부 문자열 검색에 매우 유용할 수 있습니다. 예를 들어, "users" 테이블에서 사용자의 이메일 주소를 저장하는 "email" 칼럼이 있다고 가정해봅시다. 이 경우, 이메일 주소의 도메인 부분만을 인덱스로 설정하여 접두사 인덱스를 생성할 수 있습니다. 이렇게 하면 특정 도메인으로 끝나는 이메일 주소를 검색할 때 인덱스를 활용하여 빠르게 결과를 가져올 수 있습니다.

```sql
CREATE INDEX idx_email ON users (email(10));
```

위의 예시에서는 "email" 칼럼의 처음 10자리만을 인덱싱하도록 설정한 것입니다. 이렇게 생성된 접두사 인덱스는 이메일 주소의 도메인을 검색하는 데 효율적으로 사용될 수 있습니다.

효율적인 접두사 인덱스를 선택할 때는 인덱스 칼럼의 선택도, 인덱스 크기, 쿼리 패턴 등을 고려해야 합니다. 각 상황에 맞는 적절한 접두사 인덱스를 선택하면 쿼리 성능을 향상시킬 수 있습니다.

<img src="https://cdn-images-1.medium.com/max/800/1*GgviWEclX0b0jk5UiTLydw.png" />

```sql
-- last_name: first 20 characters
CREATE INDEX idx_lastname ON customers (last_name(20))
```

last_name(20)은 임의로 입력한 숫자가 아닌, 해당 고객 정보를 식별할 수 있는 최적의 길이를 나타냅니다. 이 길이는 실제 데이터에 기반하여 결정되며, 고객 정보의 특성과 식별 가능성을 고려하여 계산됩니다. 따라서, 해당 숫자는 데이터베이스 설계자가 고객 정보를 고려하고 분석한 후 최적의 값으로 결정하게 됩니다.

만약 last_name(1)로 인덱스를 생성하고, 해당 인덱스에 의해 last_name이 'A'로 시작하는 사람이 10만 명 이상이라면, 인덱스를 사용하는 이점이 상실될 수 있습니다. 이는 선택도가 매우 낮기 때문입니다.

인덱스를 사용하는 주요 이유 중 하나는 선택도가 높은 쿼리의 성능을 향상시키기 위함입니다. 선택도는 인덱스가 필터링에 얼마나 효과적으로 사용될 수 있는지를 나타내는 지표입니다. 따라서, 저 선택도인 경우 인덱스를 생성하는 것이 효율적이지 않을 수 있습니다.

인덱스를 생성할 때는 데이터의 특성과 분포를 고려하여 적절한 선택도를 가지도록 해야 합니다. 즉, 인덱스의 유용성을 최대한 발휘할 수 있는 칼럼 부분을 선택하고 인덱스를 생성해야 합니다. 이를 통해 데이터베이스의 쿼리 성능을 향상시킬 수 있습니다.

최적의 분포를 찾는 방법에 대해 알아보겠습니다.

```sql
CREATE INDEX idx_lastname ON customers (last_name(20))

SELECT
    COUNT(DISTINCT LEFT(last_name, 1)),  -- 25
    COUNT(DISTINCT LEFT(last_name, 5)),  -- 996
    COUNT(DISTINCT LEFT(last_name, 10)) -- 996
FROM customers;
```

(last_name, 5)와 (last_name, 10) 값 사이에 차이가 없다면, (last_name, 5)가 최적의 인덱스 값으로 동작할 것입니다. 인덱스의 선택도는 인덱스 값들 사이의 유일성을 나타내는 지표이며, 선택도가 높을수록 인덱스의 효율성이 더욱 높아집니다.

따라서, (last_name, 5)가 (last_name, 10)과 차이가 없는 경우에는 인덱스의 크기를 더 작게 유지하면서 동일한 검색 성능을 얻을 수 있습니다. 이는 디스크 공간과 메모리 사용을 최적화하는 데 도움이 되며, 쿼리 실행 속도를 향상시킬 수 있습니다.

데이터베이스 설계 시에는 인덱스를 생성할 때 선택도를 고려하여 적절한 인덱스 값을 선택하는 것이 중요합니다. 선택도가 낮은 값은 인덱스로 사용하는 것보다는 다른 최적화 방법을 고려해야 할 수도 있습니다.

인덱스의 선택도(Selectivity)는 특정 값의 빈도수와 전체 레코드 수와의 비율을 나타내는 지표입니다. 선택도가 낮을수록 해당 값은 테이블에서 일반적으로 자주 발생하는 값이고, 선택도가 높을수록 해당 값은 테이블에서 드물게 발생하는 값입니다.

인덱스의 선택도가 25보다 995가 좋은 이유는 다음과 같습니다:

1. 고유성: 선택도가 995인 경우 해당 값은 테이블에서 매우 드물게 발생하는 값으로, 고유성이 높습니다. 즉, 해당 값은 테이블 내에서 거의 유일한 값을 가질 가능성이 높습니다. 이런 경우 인덱스를 사용하여 원하는 특정 값을 빠르게 찾을 수 있습니다.

2. 조회 성능: 선택도가 995인 경우 인덱스를 사용하여 해당 값을 조회하는 성능이 우수합니다. 인덱스는 선택도가 높은 값들을 빠르게 검색할 수 있기 때문에, 데이터베이스 엔진은 해당 값을 더 적은 비용으로 찾아낼 수 있습니다.

3. 쿼리 최적화: 선택도가 995인 경우 데이터베이스 엔진은 해당 값이 매우 드물게 발생하는 것을 인지하고, 쿼리 실행 계획을 최적화하는데 도움이 됩니다. 이를 통해 데이터베이스는 더 효율적으로 쿼리를 처리할 수 있으며, 쿼리의 실행 속도가 향상됩니다.

반면, 선택도가 25인 경우 해당 값은 테이블에서 비교적 자주 발생하는 값으로, 고유성이 낮습니다. 따라서 인덱스를 사용하여 해당 값을 검색하는 경우, 데이터베이스 엔진은 더 많은 레코드를 검색해야하고, 이는 더 많은 시간과 자원을 소모하게 됩니다. 또한, 인덱스를 사용하는 것보다 테이블을 순차적으로 탐색하는 것이 더 효율적일 수 있습니다.

따라서, 인덱스의 선택도가 995인 경우 해당 값은 테이블에서 특정하고 드물게 발생하는 값이기 때문에, 인덱스를 사용하여 조회 성능을 높일 수 있습니다. 데이터베이스의 성능을 최적화하기 위해서는 적절한 인덱스 전략을 선택하고, 데이터의 특성과 조회 패턴을 고려하는 것이 중요합니다.

## Full-Text Indexes

Full Text Indexes는 Search Engine 구현에 매우 유용한 기술입니다. MySQL에서 Full Text Indexes(전문 텍스트 인덱스)는 특정 문자열 데이터의 전문 검색을 지원하기 위해 사용되는 인덱스입니다. 이 인덱스는 일반적인 B-tree 인덱스와는 다르게, 전문 텍스트 검색에 최적화되어 있습니다. 전문 텍스트 인덱스를 사용하면 특정 문자열 데이터의 키워드 검색, 빠른 텍스트 매칭, 정확도 있는 검색 등을 효과적으로 수행할 수 있습니다.

1. 효율적인 검색: Full Text Indexes는 텍스트 데이터를 단어 단위로 인덱싱하고, 가중치를 부여하여 검색 결과를 정확하고 관련성 높게 반환합니다. 이를 통해 사용자가 검색어를 입력하면 빠르게 그와 관련된 문서를 찾아줄 수 있습니다.

2. 자연어 검색 지원: Full Text Indexes는 일반적인 단어 기반 검색뿐만 아니라, 자연어 검색(Natural Language Search)도 지원합니다. 사용자가 문장 형태로 검색어를 입력해도 해당 검색어를 단어로 분석하여 일치하는 결과를 반환합니다.

3. 논리 연산 지원: Search Engine에서 논리 연산자(AND, OR, NOT 등)를 활용하여 복잡한 검색 쿼리를 구현해야 할 때 Full Text Indexes가 유용합니다. 여러 키워드의 조합으로 검색할 수 있으며, 검색 결과는 가장 관련성 높은 순서대로 반환됩니다.

4. 대용량 데이터 처리: Search Engine은 많은 양의 텍스트 데이터를 빠르게 검색해야 합니다. Full Text Indexes를 사용하면 대용량 데이터에서도 효율적으로 검색할 수 있어서 빠른 검색 성능을 보장합니다.

5. 유사어 처리: Full Text Indexes는 유사어 처리(Synonym Handling)를 지원하기도 합니다. 예를 들어, 사용자가 "검색"이라는 키워드를 입력하면 "검색", "찾기", "조회" 등과 같이 유사한 의미를 가지는 단어들도 검색 결과에 포함시킬 수 있습니다.

6. 정확한 검색 결과 제공: Full Text Indexes는 단순한 문자열 일치가 아니라 문서의 내용을 분석하여 정확도 있는 검색 결과를 제공합니다. 이는 사용자가 원하는 정보를 정확하게 찾을 수 있도록 도와줍니다.

따라서, Full Text Indexes를 활용하여 Search Engine을 구현하면 빠르고 정확한 검색을 제공할 수 있으며, 사용자의 검색 경험을 크게 향상시킬 수 있습니다. Search Engine은 웹 사이트, 블로그, 문서 검색 등 다양한 분야에서 활용되며, Full Text Indexes를 사용하는 것은 효율적인 검색 기능 구현에 매우 유용한 방법입니다.

---

첨부한 쿼리 실행

블로그 포스터를 찾는 검색 탭에 "react redux"라고 검색했을 때 내부적으로 어떻게 해당 검색어에 해당하는 포스터를 찾을 수 있는지에 대해 설명드리겠습니다.

```sql
USE sql_blog;

SELECT *
FROM posts
WHERE title LIKE "%react redux%" OR
		body LIKE "%react redux%";
```

위의 쿼리는 "react redux"를 포함하는 블로그 포스터를 찾기 위해 `LIKE` 연산자를 사용하여 작성되었습니다. 하지만 이 쿼리에는 몇 가지 문제점이 있습니다:

1. 인덱스 활용 문제: 해당 쿼리는 `%react redux%`와 같이 와일드카드를 문자열의 양쪽에 사용하고 있습니다. 이는 와일드카드가 문자열의 앞이나 뒤에 위치하므로, 인덱스를 활용할 수 없게 됩니다. 즉, 인덱스를 사용하지 않고 모든 레코드를 스캔해야하는 비효율적인 검색이 발생할 수 있습니다.

2. 성능 문제: `%react redux%`와 같은 패턴은 문자열의 양쪽에 포함된 문자열을 찾기 위한 것으로, 대량의 데이터에서는 매우 느릴 수 있습니다. 와일드카드를 포함한 `LIKE` 연산은 문자열의 길이가 길어질수록 성능 저하를 초래할 수 있습니다.

3. 정확성 문제: `LIKE` 연산은 대소문자를 구분하지 않고, 불용어를 제거하지 않습니다. 따라서, "React Redux"와 "react redux"와 같은 다양한 형태의 검색어를 구분하지 않고 모두 반환할 수 있으며, 불용어가 포함된 검색 결과도 반환될 수 있습니다. 이는 검색 결과의 정확성에 영향을 미칠 수 있습니다.

쿼리의 문제점을 개선하기 위해서는 Full Text Indexes를 사용하는 것이 좋습니다. Full Text Indexes는 전문 텍스트 검색을 지원하며, 인덱스를 통해 빠르고 정확한 검색을 가능케 합니다. MySQL에서 Full Text Indexes를 활용하여 "react redux"와 같은 검색어를 처리하면, 성능과 정확성 측면에서 훨씬 우수한 검색 결과를 얻을 수 있습니다. 따라서, Full Text Indexes를 활용하는 쿼리로 검색 기능을 구현하는 것이 더 효율적이고 뛰어난 검색 성능을 제공합니다.

```sql
CREATE FULLTEXT INDEX idx_title_body ON posts (title, body);

SELECT *
FROM posts
-- Built-in FullText
WHERE MATCH(title, body) AGAINST('react redux');
```

위의 쿼리는 MySQL에서 제공하는 내장 FullText 검색 기능을 활용하여 "react redux"와 관련된 블로그 포스트를 찾는 쿼리입니다.

1. `SELECT *`: 쿼리 결과로 포스트 테이블(posts)의 모든 컬럼을 반환하도록 설정한 것입니다. 이렇게 설정하면 검색 결과로 해당 포스트의 모든 정보를 얻을 수 있습니다.

2. `FROM posts`: 검색 대상이 되는 데이터는 포스트 테이블(posts)입니다. 쿼리는 이 테이블에서 "react redux"와 관련된 포스트를 찾습니다.

3. `WHERE MATCH(title, body) AGAINST('react redux')`: 이 부분이 FullText 검색을 수행하는 부분입니다. `MATCH`와 `AGAINST` 구문을 사용하여 전문 텍스트 검색을 지정합니다.

   - `MATCH(title, body)`: 검색 대상 컬럼을 지정합니다. 여기서는 title과 body라는 두 컬럼을 검색 대상으로 설정했습니다. 즉, 제목(title)과 내용(body)에서 "react redux"와 관련된 포스트를 찾습니다.

   - `AGAINST('react redux')`: 검색어를 지정합니다. 이 쿼리에서는 "react redux"라는 검색어를 검색 대상 컬럼들에서 찾습니다. FullText 검색에서는 일반적으로 따옴표로 묶어서 검색어를 지정합니다.

FullText 검색은 내장 기능으로 제공되기 때문에, FullText 인덱스를 생성하고 해당 인덱스를 활용하여 빠르고 효율적인 검색을 수행할 수 있습니다. 또한, FullText 검색은 문자열의 빈도와 관련성을 고려하여 결과를 반환하기 때문에, 정확한 검색 결과를 얻을 수 있습니다. 이를 통해 "react redux"와 관련된 블로그 포스트를 더 쉽고 빠르게 찾을 수 있습니다. FullText 검색은 대용량 텍스트 데이터를 다루는 웹 사이트나 블로그 등에서 효과적으로 활용되며, 검색 성능을 향상시키는데 도움을 줍니다.

---

```sql
SELECT *, MATCH(title, body) AGAINST('react redux')
FROM posts
WHERE MATCH(title, body) AGAINST('react redux');
```

Relevance Score(관련성 점수)는 검색 결과의 정확도와 관련성을 나타내는 지표입니다. 전문 텍스트 검색 엔진에서 주로 사용되며, 특정 검색어와 검색 결과의 일치 정도를 평가하여 결과를 순위화하는 데 활용됩니다.

Relevance Score는 일반적으로 다음과 같은 방법으로 계산됩니다:

Score 0: No Relevance
Score 1: Yes Relevance

1. TF-IDF (Term Frequency-Inverse Document Frequency): TF-IDF는 검색어의 빈도와 특정 문서 내의 빈도를 고려하여 관련성을 평가하는 방법입니다. 검색어의 빈도가 높고, 특정 문서 내에서 자주 등장하는 단어일수록 해당 문서의 관련성이 높다고 판단합니다.

2. 논리 연산자 활용: FullText 검색에서는 논리 연산자(AND, OR, NOT 등)를 사용하여 검색 쿼리를 구성하는 경우가 많습니다. 논리 연산자는 검색 결과에 대한 관련성을 조절하는데 사용되며, 각 검색어에 대해 별도의 관련성 점수가 계산될 수 있습니다.

3. 정확한 일치 점수: 일치하는 검색어가 검색 결과에 얼마나 많이 포함되었는지에 따라 관련성 점수가 결정됩니다. 예를 들어, 검색어가 제목과 내용에 모두 포함되었을 경우 더 높은 관련성 점수를 부여할 수 있습니다.

Relevance Score는 검색 결과의 순위를 결정하는 데 사용되며, 사용자에게 더 관련성 높은 검색 결과를 상위에 표시함으로써 검색 경험을 향상시킵니다. 관련성 점수가 높은 검색 결과가 상위에 위치하면, 사용자는 원하는 정보를 더 쉽게 찾을 수 있게 됩니다.

검색 엔진은 FullText 검색과 Relevance Score 계산을 최적화하여 빠르고 정확한 검색 결과를 제공하기 위해 다양한 알고리즘과 기술을 활용합니다. Relevance Score는 효율적인 검색 기능을 구현하는데 중요한 요소이며, 검색 엔진의 성능 향상과 사용자 만족도 향상에 기여하는 중요한 요소입니다.

---

```sql
SELECT *, MATCH(title, body) AGAINST('react redux')
FROM posts
WHERE MATCH(title, body) AGAINST('react -redux' IN BOOLEAN MODE);
```

위의 쿼리는 MySQL의 Full-text Indexes를 사용하여 "react redux"를 검색하는 쿼리입니다. 다음은 쿼리를 구성하는 각 부분에 대한 설명입니다:

1. `SELECT *, MATCH(title, body) AGAINST('react redux')`: 이 부분은 SELECT 절에서 Full-text 검색을 수행하여 "react redux"와 관련된 검색 결과를 가져오도록 설정한 부분입니다. `MATCH(title, body) AGAINST('react redux')`는 "title"과 "body" 컬럼에서 "react redux"와 관련된 문서를 찾습니다. 이를 통해 Full-text 검색으로 얻은 관련성 점수를 결과로 반환합니다.

2. `FROM posts`: 검색 대상이 되는 데이터는 "posts" 테이블입니다. 쿼리는 이 테이블에서 "react redux"와 관련된 포스트를 찾습니다.

3. `WHERE MATCH(title, body) AGAINST('react -redux' IN BOOLEAN MODE)`: 이 부분은 Full-text 검색을 불리언 모드로 수행하여 "react"를 포함하지만 "redux"는 제외한 문서를 검색합니다. `AGAINST('react -redux' IN BOOLEAN MODE)` 부분에서 "react"를 반드시 포함하고 "redux"는 제외하는 검색을 수행합니다.

- "react"를 포함하는 문서는 검색됩니다.
- "redux"를 포함하는 문서는 검색 결과에서 제외됩니다.

이러한 쿼리는 "react redux"와 관련된 포스트를 찾는 데 사용됩니다. `MATCH() AGAINST()` 구문은 Full-text 검색을 위해 사용되며, 검색어와 관련된 문서의 관련성을 평가하는 데 도움을 줍니다. 불리언 모드를 사용하여 "redux"를 제외한 결과를 얻으므로, "react"와 관련된 포스트를 찾으면서 "redux"와는 무관한 검색 결과를 반환합니다. Full-text 검색은 대용량의 텍스트 데이터에서 빠르고 정확한 검색을 제공하는데 유용하며, 불리언 모드를 사용하여 검색 쿼리를 세밀하게 제어할 수 있습니다.

```sql
SELECT *, MATCH(title, body) AGAINST('react redux')
FROM posts
WHERE MATCH(title, body) AGAINST('react -redux +form' IN BOOLEAN MODE);
```

위의 쿼리는 MySQL의 Full-text Indexes를 사용하여 "react redux"와 "form"을 동시에 검색하면서 "redux"는 제외하는 쿼리입니다. 다음은 쿼리를 구성하는 각 부분에 대한 설명입니다:

1. `SELECT *, MATCH(title, body) AGAINST('react redux')`: 이 부분은 SELECT 절에서 Full-text 검색을 수행하여 "react redux"와 관련된 검색 결과를 가져오도록 설정한 부분입니다. `MATCH(title, body) AGAINST('react redux')`는 "title"과 "body" 컬럼에서 "react redux"와 관련된 문서를 찾습니다. 이를 통해 Full-text 검색으로 얻은 관련성 점수를 결과로 반환합니다.

2. `FROM posts`: 검색 대상이 되는 데이터는 "posts" 테이블입니다. 쿼리는 이 테이블에서 "react redux"와 관련된 포스트를 찾습니다.

3. `WHERE MATCH(title, body) AGAINST('react -redux +form' IN BOOLEAN MODE)`: 이 부분은 Full-text 검색을 불리언 모드로 수행하여 "react"를 포함하지만 "redux"는 제외하고 "form"을 반드시 포함하는 문서를 검색합니다. `AGAINST('react -redux +form' IN BOOLEAN MODE)` 부분에서 "react"를 반드시 포함하고 "redux"는 제외하며, "form"을 반드시 포함하는 검색을 수행합니다.

- "react"를 포함하고 "redux"는 제외하는 문서는 검색됩니다.
- "form"을 포함하는 문서가 검색됩니다.

위의 쿼리는 "react redux"와 "form"을 동시에 포함하는 포스트를 검색하는데 사용됩니다. Full-text 검색의 불리언 모드를 사용하여 검색 쿼리를 더욱 세밀하게 제어할 수 있으며, "react"와 "form"과 관련된 문서를 검색하면서 "redux"와는 무관한 결과를 얻습니다. Full-text 검색은 텍스트 데이터에서 빠르고 정확한 검색을 지원하며, 불리언 모드를 사용하여 여러 검색어를 포함하는 복잡한 검색을 수행할 수 있습니다.

```sql
SELECT *, MATCH(title, body) AGAINST('react redux')
FROM posts
WHERE MATCH(title, body) AGAINST('"handling a form' IN BOOLEAN MODE);
```

위의 쿼리는 MySQL의 Full-text Indexes를 사용하여 "handling a form"이라는 정확한 문구를 포함하는 블로그 포스트를 검색하는 쿼리입니다. 다음은 쿼리를 구성하는 각 부분에 대한 설명입니다:

1. `SELECT *, MATCH(title, body) AGAINST('react redux')`: 이 부분은 SELECT 절에서 Full-text 검색을 수행하여 "react redux"와 관련된 검색 결과를 가져오도록 설정한 부분입니다. `MATCH(title, body) AGAINST('react redux')`는 "title"과 "body" 컬럼에서 "react redux"와 관련된 문서를 찾습니다. 이를 통해 Full-text 검색으로 얻은 관련성 점수를 결과로 반환합니다.

2. `FROM posts`: 검색 대상이 되는 데이터는 "posts" 테이블입니다. 쿼리는 이 테이블에서 "react redux"와 관련된 포스트를 찾습니다.

3. `WHERE MATCH(title, body) AGAINST('"handling a form' IN BOOLEAN MODE)`: 이 부분은 Full-text 검색을 불리언 모드로 수행하여 "handling a form"이라는 정확한 문구를 포함하는 문서를 검색합니다. `AGAINST('"handling a form' IN BOOLEAN MODE)` 부분에서 "handling a form"이라는 문구를 따옴표로 묶어 정확하게 일치하는 검색을 수행합니다.

- "handling a form"이라는 정확한 문구를 포함하는 문서가 검색됩니다.

위의 쿼리는 "handling a form"이라는 정확한 문구를 포함하는 포스트를 검색하는데 사용됩니다. Full-text 검색의 불리언 모드를 사용하여 정확한 문구를 찾을 수 있으며, 따옴표로 묶어 정확하게 일치하는 문구를 검색합니다. Full-text 검색은 텍스트 데이터에서 빠르고 정확한 검색을 지원하며, 정확한 문구를 검색하는 데 사용되는 경우에 유용합니다.

---

Full-text Indexes는 MySQL에서 텍스트 기반 검색을 효율적으로 수행하기 위해 사용되는 기능입니다. Full-text Indexes를 사용하는 데에는 두 가지 모드가 있습니다: 불리언 모드(Boolean Mode)와 NLP 모드(Natural Language Mode).

1. 불리언 모드(Boolean Mode):
   불리언 모드는 Full-text 검색 시, AND, OR, NOT 같은 논리 연산자를 사용하여 검색어를 조합하는 방식입니다. 이 모드에서는 검색어를 정확히 포함하거나 포함하지 않는 등 세밀한 검색을 할 수 있습니다. 논리 연산자를 활용하여 검색 쿼리를 조합하여 원하는 문서를 찾을 수 있습니다.

예시: "react OR redux" - "javascript"
위 예시는 "react" 또는 "redux"를 포함하지만 "javascript"는 제외하는 문서를 검색합니다.

2. NLP 모드 (Natural Language Mode):
   NLP 모드는 Full-text 검색 시, 일반적인 자연어를 사용하여 검색어를 입력하는 방식입니다. 사용자는 일반 문장으로 검색어를 입력해도 되며, 검색 엔진이 자동으로 적절한 키워드로 분석합니다. 이 모드에서는 불용어(무의미한 단어)를 제거하고, 검색어의 가중치를 평가하여 결과를 반환합니다. 사용자 친화적인 검색이 가능합니다.

예시: "I want to find posts about React Redux."
위 예시는 자연어 형태로 "React Redux"와 관련된 포스트를 검색합니다.

Full-text Indexes를 사용하기 위해 먼저 테이블의 인덱스를 생성해야 합니다. 테이블의 "title"과 "body" 컬럼을 인덱싱하여 Full-text 검색을 가능하게 합니다.

인덱스 생성 쿼리:

```sql
ALTER TABLE posts ADD FULLTEXT INDEX ft_index (title, body);
```

이제 Full-text 검색을 수행하는 두 가지 모드에 대한 예시를 보겠습니다.

1. 불리언 모드(Boolean Mode) 검색 쿼리:

```sql
SELECT *, MATCH(title, body) AGAINST('React OR Redux -JavaScript' IN BOOLEAN MODE)
FROM posts
WHERE MATCH(title, body) AGAINST('React OR Redux -JavaScript' IN BOOLEAN MODE);
```

위 쿼리는 "React" 또는 "Redux"를 포함하지만 "JavaScript"는 포함하지 않는 문서를 검색합니다. 이때 `MATCH(title, body) AGAINST()`를 불리언 모드로 사용하고, 검색어를 논리 연산자(OR, -)로 구성하여 원하는 검색 결과를 얻습니다.

2. NLP 모드 (Natural Language Mode) 검색 쿼리:

```sql
SELECT *, MATCH(title, body) AGAINST('Understanding Full-text Indexes' IN NATURAL LANGUAGE MODE)
FROM posts
WHERE MATCH(title, body) AGAINST('Understanding Full-text Indexes' IN NATURAL LANGUAGE MODE);
```

위 쿼리는 자연어 형태로 "Understanding Full-text Indexes"와 관련된 문서를 검색합니다. 이때 `MATCH(title, body) AGAINST()`를 NLP 모드로 사용하여 사용자 친화적인 검색을 수행합니다.

Full-text 검색을 위해 인덱스를 생성한 후, `MATCH() AGAINST()` 구문을 사용하여 검색어와 검색 모드를 지정합니다. 불리언 모드와 NLP 모드는 사용자가 원하는 검색 상황에 따라 적절하게 선택하여 Full-text 검색을 수행할 수 있습니다.

## Composite Indexes

MySQL에서 Composite Indexes는 두 개 이상의 컬럼(열)을 함께 묶어서 하나의 인덱스로 생성하는 기능을 말합니다. 이를 다른 말로는 Multi-column Indexes 또는 Combined Indexes라고도 합니다.

Composite Indexes를 사용하면 여러 컬럼들의 조합에 대해 하나의 인덱스를 생성함으로써, 이들 컬럼들의 값을 조합하여 빠르게 특정 데이터를 찾을 수 있습니다. 각 컬럼이 개별적으로 인덱싱되는 것보다 두 개 이상의 컬럼들을 함께 인덱싱하는 것이 효율적인 쿼리 실행을 돕는데 도움이 됩니다.

Composite Indexes의 장점:

1. 쿼리 성능 개선: 두 개 이상의 컬럼을 조합하여 인덱스를 생성함으로써, 여러 조건들을 동시에 만족하는 데이터를 더 빠르게 찾을 수 있습니다.
2. 인덱스 크기 감소: 개별적으로 인덱싱하는 것보다 컬럼들을 함께 묶어서 하나의 인덱스를 생성하면 인덱스의 크기를 줄일 수 있습니다. 이는 디스크 공간을 절약하고 메모리 사용을 최적화하는 데 도움이 됩니다.
3. 더 적은 인덱스 유지 관리: Composite Indexes를 사용하면 여러 개의 인덱스를 생성하는 것보다 더 적은 수의 인덱스를 유지 관리해야 합니다.

예시를 통해 Composite Indexes를 이해해봅시다. 아래와 같은 테이블이 있다고 가정해봅시다.

```sql
CREATE TABLE products (
  id INT PRIMARY KEY,
  category VARCHAR(50),
  brand VARCHAR(50),
  price DECIMAL(10, 2)
);
```

이 테이블에서 "category"와 "brand" 컬럼에 Composite Indexes를 생성하면 다음과 같은 쿼리에서 성능 향상을 기대할 수 있습니다.

```sql
-- Composite Indexes를 사용하지 않는 경우
SELECT * FROM products WHERE category = 'Electronics' AND brand = 'Samsung';

-- Composite Indexes를 사용하는 경우
ALTER TABLE products ADD INDEX idx_category_brand (category, brand);
SELECT * FROM products WHERE category = 'Electronics' AND brand = 'Samsung';
```

Composite Indexes를 사용한 경우, "category"와 "brand" 컬럼의 값에 대한 인덱스를 묶어서 생성함으로써, 해당 쿼리의 실행 성능을 개선할 수 있습니다. 특히 두 개 이상의 컬럼을 사용하는 검색 쿼리에서 Composite Indexes는 빠른 데이터 검색에 큰 도움이 됩니다.

---

```sql
USE sql_store;
SHOW INDEXES IN customers;

EXPLAIN SELECT customer_id FROM customers
WHERE state = 'CA' AND points > 1000;
```

쿼리에서 `EXPLAIN`을 사용하여 실행 계획을 확인하면, 현재 `state` 컬럼에 대한 `idx_state` 인덱스와 `points` 컬럼에 대한 `idx_points` 인덱스가 이미 있음을 알 수 있습니다. 그러나 이 쿼리에서 `state = 'CA' AND points > 1000` 조건에 대해 별도의 Composite Indexes를 생성하는 것이 유용한 이유를 설명하겠습니다.

1. 합치는 이유:
   현재의 인덱스 `idx_state`는 `state` 컬럼에 대한 인덱스이고, `idx_points`는 `points` 컬럼에 대한 인덱스입니다. 이 두 인덱스는 각각의 컬럼에 대해 빠른 검색을 지원합니다. 그러나 두 조건(`state = 'CA' AND points > 1000`)이 모두 커버되는 인덱스가 없기 때문에 두 개의 인덱스를 병합해서 검색해야 하는 경우가 발생합니다. 이는 인덱스를 두 번 스캔하는 것보다 훨씬 비효율적입니다.

2. Composite Indexes의 이점:
   `state`와 `points` 컬럼들을 함께 묶어 Composite Indexes를 생성하면, 두 조건을 한 번에 커버할 수 있습니다. Composite Indexes를 사용하면 인덱스 스캔을 한 번만 수행하여 원하는 결과를 찾을 수 있으므로 검색 성능이 크게 향상됩니다. 이렇게 하나의 Composite Indexes로 두 개 이상의 컬럼을 함께 묶어 인덱싱하는 것은 복합적인 조건에 대한 효율적인 검색을 가능하게 합니다.

3. 인덱스 크기와 관리:
   Composite Indexes는 각각의 컬럼에 대한 인덱스보다 더 큰 인덱스가 될 수 있습니다. 하지만 두 개 이상의 컬럼을 묶어 하나의 인덱스로 생성하면 별도의 인덱스를 유지하고 관리하는 데 드는 비용이 감소합니다.

따라서, `state`와 `points` 컬럼에 대해 Composite Indexes를 생성하면 두 조건에 대한 빠른 검색을 지원할 수 있으며, 쿼리 성능이 향상됩니다. Composite Indexes를 사용하면 두 개의 인덱스를 별도로 스캔하는 비효율적인 상황을 피할 수 있습니다. 쿼리 실행 계획을 분석하여 필요한 Composite Indexes를 생성하면 더 효율적인 데이터베이스 검색을 구현할 수 있습니다.

```sql
CREATE INDEX idx_state_points on customers (state, points);

EXPLAIN SELECT customer_id FROM customers
WHERE state = 'CA' AND points > 1000;

SHOW INDEXES IN customers;
DROP INDEX idx_state ON customers;
DROP INDEX idx_points ON customers;
```

이전에는 112개의 행을 검토했다면, 이번에는 58개의 행을 검토한 것을 확인할 수 있습니다.

일반적으로 Composite Indexes보다 Single Column Indexes가 더 많이 사용됩니다. 이는 다음과 같은 이유로 설명됩니다:

1. 유연성: Single Column Indexes는 하나의 컬럼에 대해 인덱스를 생성하는 것으로, 각각의 컬럼에 대해 필요한 인덱스를 독립적으로 생성할 수 있습니다. 따라서 데이터베이스 스키마가 변화하거나 쿼리의 조건이 변경되는 경우, 필요한 인덱스를 추가, 제거, 또는 수정하기가 더 간편합니다.

2. 선택성: Composite Indexes는 두 개 이상의 컬럼을 함께 묶어 하나의 인덱스를 생성하는 것으로, 특정한 검색 조건에만 유용합니다. 따라서 모든 컬럼의 조합에 대해 Composite Indexes를 생성하는 것은 필요하지 않으며, 불필요한 인덱스를 생성하는 것을 피하기 위해 Single Column Indexes가 더 자주 사용됩니다.

3. 크기: Composite Indexes는 두 개 이상의 컬럼을 묶어 인덱스를 생성하기 때문에 각각의 컬럼에 대한 인덱스보다 더 큰 크기를 가질 수 있습니다. 따라서 인덱스 크기가 작은 Single Column Indexes가 메모리 사용과 디스크 공간을 효율적으로 관리하는 데 더 적합한 경우가 많습니다.

4. 성능: Composite Indexes는 두 개 이상의 컬럼을 포함하므로, 해당 컬럼들의 값을 조합하여 검색해야 합니다. 이로 인해 Composite Indexes는 두 개의 Single Column Indexes보다 약간 더 복잡한 검색 절차를 거쳐야 할 수 있습니다. 따라서 특정 검색 조건에 최적화된 Single Column Indexes가 성능 면에서 더 효율적인 경우가 있습니다.

물론, 데이터베이스의 구조와 쿼리의 요구 사항에 따라 Composite Indexes가 필요한 경우도 있습니다. 특히 두 개 이상의 컬럼을 조합해야 하는 복합적인 검색이나 JOIN 연산이 필요한 경우에는 Composite Indexes가 유용하게 사용될 수 있습니다. 하지만 일반적으로 Single Column Indexes가 더 많이 사용되는 경향이 있습니다. 데이터베이스 설계와 성능 최적화를 위해서는 필요에 따라 적절한 인덱스를 선택하는 것이 중요합니다.

참고: MySQL에서는 최대 16개의 컬럼으로 복합 인덱스를 생성할 수 있습니다.

## Order of Columns in Composite Indexes

<img src="https://cdn-images-1.medium.com/max/800/1*_f9CJsQKRomIu3rkKYv1DQ.png" />

- "Put the most frequently used columns first"
- "Put the columns with a higher cardinality first"
  - 성별(0 or 1) vs 도시이름 (more than 2)

컴포지트 인덱스는 관계형 데이터베이스에서 여러 개의 열로 구성된 인덱스를 말합니다. 이때 컴포지트 인덱스에서 열의 순서는 인덱스의 성능과 효율성에 영향을 미치는 중요한 요소입니다.

컴포지트 인덱스를 생성할 때는 열의 순서가 매우 중요합니다. 인덱스 정의에서 열들의 순서는 데이터가 어떻게 정렬되고 저장되는지에 영향을 미칩니다. 각 열의 위치는 데이터베이스가 다양한 유형의 쿼리를 얼마나 효율적으로 처리할 수 있는지에 영향을 줍니다.

컴포지트 인덱스의 열 순서에는 다음과 같은 규칙이 있습니다:

1. 왼쪽 최대 접두어 규칙: 인덱스의 가장 왼쪽 열들은 쿼리의 검색 조건에서 사용되어야만 인덱스가 효과적으로 사용됩니다. 만약 쿼리가 왼쪽 열들을 사용하지 않으면 컴포지트 인덱스가 효율적으로 활용되지 않을 수 있습니다.

2. 카디널리티: 높은 카디널리티(서로 다른 값의 수)를 가지는 열은 일반적으로 인덱스의 처음에 위치시키는 것이 좋습니다. 높은 카디널리티 열은 선택적인 필터링이나 검색에 더 효율적이기 때문에 인덱스를 더 효과적으로 사용할 수 있습니다.

3. 동등 연산 vs. 범위 연산: 동등 연산(정확한 일치) 조건을 사용하는 열은 범위 연산(크기 비교) 조건을 사용하는 열보다 먼저 인덱스에 포함되어야 합니다. 이렇게 함으로써 인덱스는 동등 연산과 범위 연산 모두에서 효율적으로 데이터를 필터링할 수 있습니다.

4. 정렬 순서: 인덱스의 각 열은 쿼리에서 사용하는 정렬 순서와 일치해야 합니다. 만약 인덱스의 열이 오름차순으로 정렬되어 있으면, 쿼리에서도 해당 열을 오름차순으로 검색해야 하며, 반대로 인덱스의 열이 내림차순으로 정렬되어 있으면 쿼리에서도 해당 열을 내림차순으로 검색해야 합니다.

컴포지트 인덱스를 효과적으로 생성하기 위해서는 데이터베이스 관리자나 개발자가 쿼리의 패턴을 분석하고, 가장 자주 사용되는 검색 조건들을 파악해야 합니다. 이렇게 쿼리의 패턴을 이해하면 컴포지트 인덱스의 열 순서를 적절하게 배치하여 최상의 쿼리 성능을 확보할 수 있습니다.

---

```sql
SELECT customer_id
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%';
```

Cardinality Check

```sql
SELECT
   COUNT(DISTINCT state), -- 48
   COUNT(DISTINCT last_name) -- 997
FROM customers;
```

카디널리티를 고려했을 때, last_name 컬럼이 더 높은 카디널리티를 나타내기 때문에, last_name일 먼저 사용하는 것이 인덱스 성능에 유리합니다.

```sql
EXPLAIN SELECT customer_id
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%';

CREATE INDEX idx_lastname_state ON customers (last_name, state);

EXPLAIN SELECT customer_id
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%'; -- 40
```

<img src="https://cdn-images-1.medium.com/max/800/1*wRbFjo7mFbGIcoI0hicN0Q.png" />

지금의 방식을 살펴보면, 이름을 알파벳 순서로 먼저 정렬한 후에 도시 이름을 찾는 방식으로 동작하고 있습니다. 하지만 현재의 시나리오에서는 이러한 방식이 다소 비효율적으로 느껴집니다. 따라서 인덱스를 더 효율적으로 활용하기 위해 순서를 변경하려고 합니다.

변경할 인덱스 생성 순서는 다음과 같습니다:

1. 도시 이름(city) 컬럼을 먼저 작성합니다.
2. 이름(name) 컬럼을 그 다음에 작성합니다.

이렇게 변경함으로써 도시 이름을 먼저 필터링하여 해당 도시의 이름을 가지는 사람들을 찾게 됩니다. 그리고 해당 결과들 중에서 이름을 알파벳 순서로 정렬하면 원하는 검색 결과를 빠르게 얻을 수 있습니다.

이렇게 인덱스 생성 순서를 변경함으로써 데이터베이스는 먼저 도시 이름을 이용하여 필터링하고, 그 후에 이름을 알파벳 순서로 정렬하는데 더 적은 시간과 자원을 사용하게 됩니다. 이는 검색 성능을 향상시키고 데이터베이스의 응답 속도를 더욱 빠르게 만들어주는 장점을 가지게 됩니다. 따라서 변경된 인덱스 생성 순서를 적용하여 데이터베이스의 성능을 최적화하고 더 효율적으로 동작할 수 있도록 하겠습니다.

```sql
CREATE INDEX idx_state_lastname ON customers (state, last_name);

EXPLAIN SELECT customer_id
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%'; -- 7

EXPLAIN SELECT customer_id
FROM customers
WHERE state = 'NY' AND last_name LIKE 'A%'; -- 2
```

물론 현재 상황에서는 `idx_state_lastname` 인덱스가 효과적이지만, 상황에 따라 다른 인덱스가 필요한 경우 다음과 같이 쿼리를 작성할 수 있습니다.

```sql
EXPLAIN SELECT customer_id
FROM customers
USE INDEX (idx_lastname_state)
WHERE state = 'CA' AND last_name LIKE 'A%';
```

현재 쿼리의 조건에서 도시는 정해진 값으로 사용되지만, 이름은 A로 시작하는 범위를 기준으로 한정됩니다. 따라서 `idx_state_lastname` 인덱스가 더 효과적일 수 있습니다. 하지만 도시 값도 범위로 한정된다면, 인덱스 성능은 달라질 수 있습니다.

예를 들어, 도시 값도 "A"로 시작하는 범위로 한정된다면 `idx_state_lastname` 인덱스의 효과는 감소할 수 있습니다. 왜냐하면 도시와 이름의 조건이 모두 범위로 한정되기 때문에 인덱스를 이용하여 빠르게 검색하는데에 제한이 생기기 때문입니다.

이런 경우에는 두 컬럼을 모두 고려하여 Composite Indexes를 생성하는 것이 효과적일 수 있습니다. 즉, `idx_lastname_state`와 같이 이름을 먼저 작성하고 그 다음에 도시를 작성하는 인덱스를 생성할 수 있습니다. 이렇게 하면 이름으로 먼저 필터링하고, 그 후에 도시를 찾는 방식으로 인덱스를 이용하여 빠르게 검색할 수 있습니다.

따라서 인덱스를 생성할 때는 쿼리의 조건과 필터링되는 컬럼들을 고려하여 가장 효과적인 순서로 Composite Indexes를 생성하는 것이 중요합니다. 쿼리의 조건과 데이터의 특성에 따라서 인덱스를 최적화하여 데이터베이스의 성능을 향상시키는데에 유의해야 합니다.

```sql
EXPLAIN SELECT customer_id
FROM customers
USE INDEX (idx_lastname_state)
WHERE state LIKE 'A%' AND last_name LIKE 'A%'; -- 40

EXPLAIN SELECT customer_id
FROM customers
USE INDEX (idx_state_lastname)
WHERE state LIKE 'A%' AND last_name LIKE 'A%'; -- 51
```

쿼리의 조건이 도시가 딱 정해진 값으로 사용되는 경우에는 `idx_state_lastname` 인덱스가 더 효율적입니다. 왜냐하면 도시가 정해진 값으로 사용되기 때문에 해당 인덱스를 이용하여 바로 정확한 결과를 찾을 수 있기 때문입니다.

```sql
EXPLAIN SELECT customer_id
FROM customers
USE INDEX (idx_state_lastname)
WHERE state = 'NY' AND last_name LIKE 'A%';
```

```sql
DROP INDEX idx_lastname_state ON customers;
```

만약 `last_name` 컬럼만을 기준으로 검토하는 경우에는 `idx_state_lastname` 인덱스가 비효율적입니다. 이유는 `idx_state_lastname` 인덱스가 도시와 이름 순서로 구성되어 있기 때문입니다. 따라서 `last_name` 컬럼만을 기준으로 검색하더라도 인덱스에서는 불필요한 도시 정보가 함께 포함되어 있어서 인덱스의 크기가 커지고, 불필요한 추가 작업을 수행해야 하기 때문에 성능이 떨어집니다.

```sql
EXPLAIN SELECT * FROM customers
WHERE last_name LIKE 'A%';
```

위와 같이 `last_name` 컬럼만으로 검색하는 경우에는 `idx_lastname` 인덱스가 효과적입니다. `idx_lastname` 인덱스는 `last_name` 컬럼만으로 구성되어 있기 때문에 원하는 조건과 인덱스가 정확히 일치하므로 인덱스를 빠르게 이용하여 검색할 수 있습니다.

Composite Indexes를 생성할 때는 쿼리의 조건과 필터링되는 컬럼들을 고려하여 최적의 순서로 인덱스를 생성하는 것이 중요합니다. 특히 쿼리의 조건이 다양한 컬럼들로 이루어져 있거나, 각각의 컬럼들에 대해 검색이 필요한 경우에는 단일 컬럼 인덱스보다 Composite Indexes를 고려하여 최적화된 검색 성능을 얻을 수 있습니다.

---

컴포지트 인덱스를 생성할 때 어떤 컬럼을 먼저 작성해야하는지 결정하는 방법은 해당 테이블에 어떤 쿼리가 자주 실행되는지, 어떤 조건으로 데이터를 검색하고 필터링하는지에 따라 다릅니다. 일반적으로 다음과 같은 고려 사항을 따르면서 결정할 수 있습니다.

1. 검색 조건의 중요도:
   가장 자주 사용되는 검색 조건이나 필터링 조건을 우선적으로 고려합니다. 빈번하게 사용되는 컬럼을 먼저 작성하는 것이 성능에 더 도움이 됩니다.

2. 카디널리티(Cardinality):
   각 컬럼의 고유한 값의 개수를 의미하는 카디널리티를 고려합니다. 카디널리티가 높은 컬럼을 먼저 작성하는 것이 인덱스의 효율성을 높일 수 있습니다.

3. 컬럼의 크기:
   인덱스를 구성하는 컬럼의 크기를 고려하여 작은 크기의 컬럼을 먼저 작성하는 것이 일반적으로 좋습니다. 작은 크기의 컬럼을 먼저 작성하면 인덱스의 크기를 줄이고 검색 성능을 향상시킬 수 있습니다.

4. 복합 검색 조건:
   복합 검색 조건을 고려하여 해당 조건에 맞는 컬럼을 먼저 작성하는 것이 좋습니다. 예를 들어, 두 개 이상의 컬럼을 조합하여 검색하는 경우, 해당 컬럼들을 순서대로 작성하는 것이 효율적입니다.

5. ORDER BY 절과 GROUP BY 절:
   ORDER BY 절이나 GROUP BY 절에 사용되는 컬럼을 먼저 작성하는 것이 성능에 도움이 됩니다. 이러한 절들은 인덱스를 활용하여 데이터를 정렬하거나 그룹화하는 데에 사용되기 때문입니다.

이러한 고려 사항들을 바탕으로 어떤 컬럼을 먼저 작성할지 결정하고, 해당 순서대로 컴포지트 인덱스를 생성하면 검색 성능을 최적화할 수 있습니다. 또한, 인덱스를 생성한 후에도 쿼리 실행 계획을 확인하고 성능을 모니터링하여 필요에 따라 인덱스를 조정하는 것이 중요합니다.

## When Indexes are Ignored

MySQL에서 "When Indexes are Ignored"란 인덱스가 무시되는 상황을 가리킵니다. 인덱스는 데이터베이스 테이블의 검색 및 조회 성능을 향상시키는 데 사용되는 데이터 구조입니다. 그러나 때로는 MySQL 옵티마이저가 인덱스를 사용하지 않을 수 있습니다. 이는 주로 다음과 같은 상황에서 발생할 수 있습니다:

1. 인덱스 사용으로 인한 성능 저하: 데이터베이스 테이블이 작고 간단한 쿼리의 경우 인덱스를 사용하는 대신 테이블 스캔이 더 빠를 수 있습니다. 작은 테이블의 경우 인덱스를 찾는 추가 작업으로 인해 성능 저하가 발생할 수 있습니다.

2. WHERE 절에 인덱스를 사용할 수 없는 경우: 일부 쿼리는 WHERE 절에 인덱스를 사용할 수 없는 조건으로 작성되어 인덱스를 무시합니다. 예를 들어, 함수나 연산자로 인해 인덱스를 사용할 수 없는 경우가 있습니다.

3. 테이블 조인 시 인덱스 무시: 조인 작업에서 인덱스를 사용할 수 없는 경우 옵티마이저가 인덱스를 무시할 수 있습니다. 조인 조건이 인덱스를 활용하지 못하면 성능이 저하될 수 있습니다.

4. 데이터 분포가 너무 일정한 경우: 인덱스는 데이터 분포가 특정 범위에 집중되어 있는 경우에 가장 효과적으로 작동합니다. 그러나 데이터가 너무 일정한 분포를 갖는 경우에는 인덱스를 사용하기보다는 테이블 스캔이 더 효율적일 수 있습니다.

5. LIMIT 사용 시 인덱스 무시: LIMIT 절이 쿼리에 적용되는 경우, MySQL 옵티마이저는 인덱스를 무시하고 처음 n개의 결과를 가져오는 것이 효율적이라고 판단할 수 있습니다.

인덱스가 무시되는 경우에는 쿼리 실행 계획을 확인하여 인덱스 사용 여부를 파악하는 것이 중요합니다. EXPLAIN을 사용하여 쿼리 실행 계획을 분석하고, 인덱스가 적절히 사용되지 않는 경우 인덱스를 조정하거나 쿼리를 최적화하여 성능을 향상시킬 수 있습니다.

```sql
EXPLAIN SELECT customer_id FROM customers
WHERE state = 'CA' OR points > 1000; -- 1010
```

위 쿼리의 결과를 보면 `type: index`를 사용한 것을 확인할 수 있습니다. 여기서 `index`가 의미하는 바는 MySQL이 인덱스를 이용한 데이터 액세스 방식을 사용한다는 것입니다. 이 방식은 전체 테이블 스캔보다 빠른 이유는 디스크에 접근해 데이터를 직접 읽는 것이 아니라, 메모리 상의 인덱스 값을 검토하여 필요한 데이터를 빠르게 가져오기 때문입니다. 즉, 인덱스를 사용함으로써 데이터베이스는 테이블의 모든 레코드를 확인하지 않고 필요한 레코드만 효율적으로 찾아낼 수 있습니다. 이는 데이터 액세스 속도를 크게 향상시켜줍니다.

어떻게 쿼리를 최적화 할 수 있을까요?

```sql
EXPLAIN
	SELECT customer_id FROM customers
	WHERE state = 'CA'
    UNION
    SELECT customer_id FROM customers
    WHERE points > 1000;
```

`points index` 생성을 통해 조금 더 최적화를 할 수 있습니다.

```sql
CREATE INDEX idx_points ON customers (points);

EXPLAIN
	SELECT customer_id FROM customers
	WHERE state = 'CA'
    UNION
    SELECT customer_id FROM customers
    WHERE points > 1000;
```

주어진 쿼리에서는 인덱스를 사용하여 데이터를 검색할 수 없으므로, 전체 `customers` 테이블을 스캔해야 합니다.

`WHERE` 절에서 `points + 10 > 2010`과 같은 수식이 사용되기 때문에 MySQL 옵티마이저는 이를 인덱스로 직접 사용할 수 없습니다. 인덱스는 주로 비교 연산자를 직접 사용하는 경우에 효과적으로 작동합니다. 하지만 수식이나 함수가 포함된 경우에는 옵티마이저가 해당 인덱스를 활용하지 못하고, 모든 행을 비교해야 하는 전체 테이블 스캔을 수행해야 합니다.

따라서 위 쿼리의 실행 계획에서 `type`은 `ALL`로 표시되며, `key`는 `NULL`로 표시됩니다. `ALL` 타입은 테이블의 모든 행을 검색해야 함을 나타내고, `key: NULL`은 인덱스를 이용하여 검색하지 않는다는 것을 의미합니다.

이 경우, 쿼리의 성능을 향상시키기 위해서는 `points + 10` 값을 계산하여 새로운 컬럼으로 추가한 뒤, 그 컬럼에 인덱스를 생성하는 것이 한 가지 방법입니다. 그러면 인덱스를 이용하여 더 효율적으로 데이터를 검색할 수 있습니다.

```sql
EXPLAIN SELECT customer_id FROM customers
WHERE points + 10 > 2010;
```

주어진 쿼리에서는 `points` 필드에 대한 조건이 단순 비교 연산자인 `>`만 사용되므로, `points` 열에 인덱스가 있다면 해당 인덱스를 활용하여 빠르게 데이터를 검색할 수 있습니다.

`WHERE` 절에서 `points > 2020`과 같이 단순한 비교를 하면 MySQL 옵티마이저는 `points` 컬럼에 대한 인덱스를 활용하여 효율적으로 검색할 수 있습니다. 이러한 경우 인덱스를 이용한 검색을 통해 필요한 데이터를 빠르게 찾아낼 수 있으며, 전체 `customers` 테이블을 스캔하는 것보다 훨씬 효율적으로 작업이 이루어집니다.

따라서 위의 수정된 쿼리인 `SELECT customer_id FROM customers WHERE points > 2020;`의 실행 계획에서 `type`은 `range`로 표시되며, `key`는 `points index`를 사용하여 검색한다는 것을 의미합니다. `range` 타입은 인덱스 범위 검색을 나타내며, `points index`를 이용하여 필요한 데이터만 검색한다는 것을 보여줍니다.

이렇게 수정된 쿼리는 `points` 컬럼에 인덱스가 존재하고, 해당 인덱스를 활용하여 빠르게 원하는 데이터를 찾아낼 수 있기 때문에, 쿼리 성능이 향상될 것입니다.

```sql
EXPLAIN SELECT customer_id FROM customers
WHERE points > 2020;
```

따라서 열의 값이 자주 변경되는 경우에는 쿼리 성능을 최적화하기 위해 적절한 인덱스를 선택하는 것이 중요합니다. 열 자체에 변화를 주지 않고, 우측의 조건에 상수 값을 사용하여 쿼리를 작성하는 것이 인덱스를 통해 최적화하는 데 용이하며, 이는 데이터베이스의 성능 향상에 도움이 됩니다.

## Using Indexes for Sorting

MySQL에서 "Using Indexes for Sorting"은 정렬 작업에서 인덱스를 사용하여 결과를 정렬하는 기능을 가리킵니다. 정렬은 데이터를 특정 기준으로 순서대로 나열하는 작업으로, `ORDER BY` 절을 사용하여 쿼리 결과를 정렬할 수 있습니다.

일반적으로 `ORDER BY`를 사용하여 데이터를 정렬하면 MySQL은 정렬을 위해 인덱스를 사용하지 않고, 결과를 가져온 후 메모리나 디스크에서 정렬 작업을 수행합니다. 이는 정렬 대상이 많은 경우 성능 저하를 유발할 수 있습니다.

그러나 인덱스가 존재하면 MySQL은 `ORDER BY` 절과 일치하는 인덱스를 사용하여 데이터를 정렬할 수 있습니다. 이를 "Using Indexes for Sorting"이라고 합니다. 인덱스를 이용하여 정렬을 수행하면 디스크 또는 메모리에서 정렬할 필요 없이 인덱스의 키 값을 사용하여 빠르게 정렬된 결과를 가져올 수 있습니다. 이를 통해 정렬 작업의 성능이 크게 향상될 수 있습니다.

`Using Indexes for Sorting`은 특히 정렬 작업이 많이 필요한 쿼리에서 유용하며, 대용량 데이터베이스에서 더욱 두드러집니다. 인덱스된 컬럼과 정렬 기준이 일치하는 경우 MySQL은 가능한 경우에 인덱스를 사용하여 정렬 작업을 최적화합니다.

인덱스를 효과적으로 사용하여 정렬을 수행하려면 정렬 기준과 일치하는 인덱스를 만들어야 합니다. 또한 인덱스된 컬럼을 이용하여 정렬 작업이 필요한 쿼리를 최적화하도록 주의해야 합니다. 적절한 인덱스를 구성하면 `Using Indexes for Sorting`을 통해 쿼리의 성능을 크게 향상시킬 수 있습니다.

```sql
SHOW INDEXES IN customers;

EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state; -- 1011

EXPLAIN
SELECT customer_id
FROM customers
ORDER BY first_name
```

쿼리 실행 계획에서 `Extra: Using Index`를 볼 수 있다는 것은 MySQL이 인덱스를 사용하여 데이터를 정렬한다는 것을 의미합니다. 이는 인덱스가 존재하여 정렬 작업에 효과적으로 활용되고 있다는 것을 나타냅니다. `Using Index`는 쿼리의 성능을 향상시키기 위해 인덱스를 이용하여 정렬을 수행하고 있다는 긍정적인 표시입니다.

한편, `first_name`과 같은 열이 인덱스가 없는 경우에는 MySQL이 정렬을 위해 추가적인 정렬 작업을 수행해야 합니다. 이러한 경우에는 `Extra: Using FileSort`가 표시됩니다. `Using FileSort`는 MySQL이 디스크 기반의 임시 파일을 생성하여 정렬 작업을 처리하고 있다는 의미입니다. 이는 정렬에 추가적인 비용과 시간이 소요되는 작업이기 때문에 성능 저하를 유발할 수 있습니다.

따라서 정렬을 수행할 때에는 인덱스를 활용하여 정렬을 하도록 최적화하는 것이 좋습니다. 필요한 경우 적절한 인덱스를 생성하고, 정렬에 사용할 컬럼에 인덱스를 적용하여 `Using Index`를 유도하여 쿼리 성능을 향상시킬 수 있습니다. 특히 대용량의 데이터베이스에서 정렬 작업은 성능에 큰 영향을 미치므로, 인덱스를 통한 최적화를 고려하는 것이 중요합니다.

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state;
SHOW STATUS LIKE 'last_query_cost';
-- value: 102.7499

EXPLAIN
SELECT customer_id
FROM customers
ORDER BY first_name;
SHOW STATUS LIKE 'last_query_cost';
-- value: 1118.2240
```

주어진 코드는 두 개의 쿼리를 실행하고 `EXPLAIN`을 사용하여 각 쿼리의 실행 계획을 확인한 후, `SHOW STATUS`를 통해 `last_query_cost` 값을 확인하는 것입니다.

1. 첫 번째 쿼리:

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state;
SHOW STATUS LIKE 'last_query_cost';
-- value: 102.7499
```

이 쿼리는 `customers` 테이블에서 `customer_id`를 가져오며, `ORDER BY state`를 통해 `state` 컬럼을 기준으로 정렬합니다. 쿼리의 실행 계획을 확인하면, `type`이 `index`로 표시되며, `key`에 `state` 컬럼에 대한 인덱스가 사용되고 있음을 알 수 있습니다. 따라서 MySQL은 `state` 컬럼에 인덱스를 활용하여 데이터를 정렬하고 있으며, `last_query_cost` 값은 102.7499입니다.

2. 두 번째 쿼리:

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY first_name;
SHOW STATUS LIKE 'last_query_cost';
-- value: 1118.2240
```

이 쿼리는 `customers` 테이블에서 `customer_id`를 가져오며, `ORDER BY first_name`을 통해 `first_name` 컬럼을 기준으로 정렬합니다. 쿼리의 실행 계획을 확인하면, `type`이 `ALL`로 표시되며, `key`에 인덱스를 사용하지 않고 테이블의 모든 행을 스캔하고 있음을 알 수 있습니다. 이 경우 `first_name` 컬럼에 인덱스가 없으므로 MySQL은 추가적인 정렬 작업을 수행해야 하며, `last_query_cost` 값은 1118.2240입니다.

결론적으로, 두 번째 쿼리에서는 인덱스를 사용하지 않고 테이블의 모든 행을 스캔하여 정렬을 수행하므로 비용이 많이 듭니다. 따라서 정렬에 사용하는 컬럼에 인덱스를 생성하거나, 쿼리를 최적화하여 비용을 줄이는 것이 성능 향상에 도움이 될 수 있습니다. 인덱스를 이용하여 정렬 작업을 최적화하는 것이 데이터베이스 쿼리 성능 향상에 중요한 요소 중 하나입니다.

두 개의 쿼리를 비교해보겠습니다.

1. 첫 번째 쿼리:

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state, points;
SHOW STATUS LIKE 'last_query_cost';
```

이 쿼리에서는 `customers` 테이블에서 `customer_id`를 가져오며, `ORDER BY state, points`를 통해 먼저 `state` 컬럼을 기준으로 정렬하고, 그 다음에 `points` 컬럼을 기준으로 정렬합니다. 이 쿼리의 실행 계획을 확인하면, 인덱스로 정의되어 있는 컬럼인 `state`와 `points` 순서로 정렬하는데에 인덱스를 활용할 수 있습니다. 인덱스가 정렬 순서와 일치하면, MySQL은 인덱스를 이용하여 데이터를 정렬하고 필요한 데이터만을 가져올 수 있습니다. 이러한 경우에는 `last_query_cost` 값이 작게 나올 가능성이 높습니다.

2. 두 번째 쿼리:

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state, first_name, points;
SHOW STATUS LIKE 'last_query_cost';
```

이 쿼리에서는 `customers` 테이블에서 `customer_id`를 가져오며, `ORDER BY state, first_name, points`를 통해 먼저 `state` 컬럼을 기준으로 정렬하고, 그 다음에 `first_name` 컬럼을 기준으로 정렬하고, 마지막으로 `points` 컬럼을 기준으로 정렬합니다. 하지만 이 쿼리에서는 `first_name` 컬럼이 인덱스로 정의되어 있지 않습니다. 따라서 `first_name` 컬럼을 기준으로 정렬하기 위해서는 인덱스를 활용할 수 없고, `full table scan`을 수행하여 테이블의 모든 행을 스캔하여 정렬을 수행해야 합니다. 이 경우에는 `last_query_cost` 값이 높게 나올 가능성이 높습니다.

따라서 인덱스로 정의되어 있고, 정렬 순서와 일치하는 컬럼을 사용하는 경우에는 인덱스를 활용하여 최적화된 정렬을 실행할 수 있습니다. 하지만 인덱스로 정의되지 않은 컬럼이나 정렬 순서와 일치하지 않는 컬럼을 사용하는 경우에는 인덱스를 활용하지 못하고 추가적인 비용이 발생할 수 있으므로 주의해야 합니다. 올바른 인덱스를 생성하여 쿼리 성능을 최적화하는 것이 중요합니다.

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state, points DESC;
SHOW STATUS LIKE 'last_query_cost';
```

쿼리의 `ORDER BY` 절에서 정렬 순서를 변경하면 인덱스를 활용하지 못하고 추가적인 정렬 작업이 필요하게 됩니다. 이로 인해 `Extra: Using index; Using filesort`와 같은 실행 계획이 출력되며, 성능이 저하될 수 있습니다.

`EXPLAIN` 결과에서 `Using index`는 인덱스를 이용하여 데이터를 읽는다는 의미이고, `Using filesort`는 정렬을 위해 임시 파일을 사용한다는 의미입니다. 따라서 `ORDER BY state, points DESC`와 같이 역순으로 정렬할 경우에는 인덱스를 활용하여 정렬할 수 없으며, `filesort` 방식을 사용하여 추가적인 정렬 작업을 수행해야 합니다.

정렬 순서를 변경하여 인덱스를 활용하지 못하는 경우에는 성능이 떨어질 수 있으므로, 쿼리를 최적화하는데에는 정렬 순서도 고려해야 합니다. 적절한 인덱스를 생성하고, 인덱스된 컬럼으로 정렬 순서를 지정하여 최적화된 정렬을 수행하는 것이 성능 향상에 도움이 됩니다. 데이터베이스의 크기와 쿼리의 복잡성에 따라 인덱스와 정렬을 최적화하는 것이 중요합니다.

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state DESC, points DESC;
SHOW STATUS LIKE 'last_query_cost';
```

`ORDER BY state DESC, points DESC`와 같이 두 개의 컬럼을 모두 내림차순으로 정렬하는 경우에는 인덱스를 활용한 최적화가 가능합니다. 이런 경우 쿼리의 실행 계획에서 `Extra: Backward index scan; Using index;`와 같은 메시지가 표시되며, 성능이 향상됩니다.

`Backward index scan`은 인덱스를 역방향으로 스캔하여 데이터를 가져오는 것을 의미합니다. 즉, 인덱스의 리프 노드를 거꾸로 탐색하여 내림차순으로 정렬된 결과를 얻습니다. 이렇게 인덱스를 역방향으로 스캔하면 내림차순으로 정렬하는데에도 인덱스를 활용할 수 있으며, 정렬 작업이 효율적으로 수행됩니다.

`Using index`는 `state`와 `points` 컬럼이 인덱스에 포함되어 있다는 것을 의미합니다. 쿼리에서 요청한 컬럼들이 인덱스에 포함되어 있을 때, MySQL은 인덱스만으로 결과를 가져올 수 있으며 따라서 테이블 스캔이나 파일 정렬 작업이 필요하지 않습니다.

따라서 `ORDER BY state DESC, points DESC`와 같이 두 개의 컬럼을 모두 내림차순으로 정렬하는 경우에는 인덱스를 활용한 최적화가 가능하여 성능이 향상됩니다. 정렬 순서와 인덱스를 잘 조합하여 쿼리를 최적화하는 것이 데이터베이스 성능 향상에 중요합니다.

```
-- (a, b)
-- a
-- a, b
-- a DESC, b DESC
-- a, c, b (사용 x)
-- b (사용 x)
```

```sql
b(사용 x)

EXPLAIN
SELECT customer_id
FROM customers
ORDER BY points

SHOW STATUS LIKE "last_query_cost";
```

```sql
EXPLAIN
SELECT customer_id
WHERE state = "CA"
FROM customers
ORDER BY points

SHOW STATUS LIKE "last_query_cost";
```

## Covering Indexes

MySQL Covering Indexes(커버링 인덱스)는 쿼리에서 필요로 하는 모든 데이터를 인덱스에서 가져오는 인덱스의 형태를 말합니다. 일반적인 인덱스는 인덱스의 키 값을 사용하여 특정 레코드를 찾는 데에만 사용되고, 해당 레코드를 찾은 뒤에는 디스크에서 나머지 데이터를 가져와야 합니다. 하지만 커버링 인덱스는 인덱스 자체만으로 쿼리 결과에 필요한 모든 데이터를 포함하여 반환하므로, 디스크 액세스를 줄여서 쿼리 성능을 크게 향상시킵니다.

일반적으로 커버링 인덱스는 다음과 같은 상황에서 유용하게 사용됩니다:

1. SELECT 문에 필요한 컬럼들이 모두 인덱스에 포함되어 있을 때.
2. SELECT 문에서 사용하는 컬럼들이 자주 업데이트되거나 변경되지 않을 때.

커버링 인덱스를 사용하면 디스크 액세스를 줄여서 쿼리 실행 비용을 최소화할 수 있습니다. 또한 인덱스를 활용하여 데이터베이스 캐시를 효과적으로 사용할 수 있으며, 데이터베이스 서버의 성능을 크게 향상시킵니다.

커버링 인덱스를 생성하는 것은 쿼리 성능 최적화를 위한 중요한 전략 중 하나입니다. 필요한 컬럼들을 인덱스에 포함시켜 쿼리의 필요 데이터를 인덱스만으로 가져오는 것은 데이터베이스의 성능을 높이는 데에 도움이 됩니다. 하지만 모든 상황에서 커버링 인덱스가 항상 효율적인 것은 아니며, 데이터베이스의 크기, 쿼리의 복잡성, 데이터의 업데이트 빈도 등을 고려하여 적절한 인덱스를 생성해야 합니다.

```sql
EXPLAIN
SELECT customer_id
FROM customers
ORDER BY state;
SHOW STATUS LIKE 'last_query_cost';
```

위 쿼리는 `customers` 테이블에서 `customer_id` 컬럼을 조회하며, `ORDER BY state`를 통해 `state` 컬럼을 기준으로 정렬합니다. 이때 `customer_id` 컬럼을 조회한 이유는, `customer_id` 컬럼이 기본적으로 인덱스로 내부적으로 생성되기 때문입니다. 또한, `state` 컬럼에는 `secondary index`가 존재하며, 이 `secondary index`는 내부적으로 `state`와 `points` 컬럼을 함께 사용하는 인덱스로 구성되어 있습니다. 즉, `customer_id, state, and points` 세 개의 컬럼에 대한 인덱스가 내부적으로 생성되어 있습니다. 따라서 이러한 인덱스를 이용하여 쿼리를 실행합니다.

```sql
EXPLAIN
SELECT *
FROM customers
ORDER BY state;
SHOW STATUS LIKE 'last_query_cost';
```

반면에 위 쿼리는 `customers` 테이블에서 모든 컬럼을 조회하며, `ORDER BY state`를 통해 `state` 컬럼을 기준으로 정렬합니다. 이 경우에는 `SELECT *`를 사용하여 모든 컬럼을 조회하게 되므로, 인덱스로 정의되지 않은 컬럼들도 포함되어 있습니다. 따라서 어쩔 수 없이 `Using filesort`를 사용하여 정렬 작업을 수행해야 합니다. `Using filesort`는 인덱스를 사용하지 않고 임시 파일을 생성하여 정렬 작업을 처리하는 것으로, 성능이 좋지 않을 수 있습니다.

따라서 인덱스가 정의되지 않은 컬럼들을 조회하는 경우에는 최적화된 정렬을 위해 쿼리에 필요한 컬럼만 선택하여 조회하는 것이 좋습니다. 필요한 컬럼만을 선택하여 조회하면 MySQL이 인덱스를 더 효율적으로 활용할 수 있고, `Using filesort`와 같은 성능 저하를 피할 수 있습니다. 쿼리 성능을 최적화하기 위해 필요한 컬럼만을 선택하여 조회하는 것이 중요합니다.

```sql
EXPLAIN
SELECT customer_id, state
FROM customers
ORDER BY state;
SHOW STATUS LIKE 'last_query_cost';
```

## Index Maintenance

MySQL의 인덱스 유지 관리(Index Maintenance)는 데이터베이스에서 인덱스를 생성, 수정, 삭제하고, 인덱스를 사용하여 데이터를 효율적으로 유지하는 과정을 의미합니다. 인덱스는 데이터베이스 성능을 향상시키는 데에 중요한 역할을 하며, 인덱스의 유지 관리는 데이터베이스 성능에 직접적으로 영향을 미치기 때문에 매우 중요합니다.

인덱스 유지 관리의 주요 작업은 다음과 같습니다:

1. 인덱스 생성: 인덱스를 사용하여 데이터에 빠르게 접근하기 위해서는 먼저 인덱스를 생성해야 합니다. 인덱스 생성은 데이터베이스 테이블의 특정 컬럼이나 컬럼의 조합에 대해 인덱스를 만들어 내부적으로 B-tree 또는 Hash 등의 데이터 구조로 저장합니다.

2. 인덱스 수정: 데이터베이스 테이블에 데이터가 추가, 수정, 삭제될 때 인덱스도 함께 업데이트해야 합니다. 데이터가 추가되면 인덱스에 새로운 엔트리를 추가하고, 데이터가 수정되면 해당 인덱스 값을 갱신하고, 데이터가 삭제되면 인덱스에서 해당 엔트리를 제거합니다.

3. 인덱스 재구성: 데이터베이스의 테이블에 대량의 데이터가 추가되거나 삭제되는 경우, 인덱스의 성능이 저하될 수 있습니다. 이런 경우 주기적으로 인덱스를 재구성하는 작업이 필요할 수 있습니다.

4. 인덱스 삭제: 더 이상 필요하지 않은 인덱스는 삭제하여 데이터베이스의 리소스를 최적화할 수 있습니다.

인덱스 유지 관리는 데이터베이스의 크기와 데이터의 변경 빈도에 따라 다르며, 데이터베이스의 성능을 최적화하기 위해 적절한 인덱스 유지 관리가 필요합니다. MySQL은 인덱스 유지 관리를 자동으로 수행하지만, 큰 데이터베이스에서는 주기적인 인덱스 재구성이나 필요 없는 인덱스를 삭제하는 등의 작업을 고려하여 데이터베이스의 성능을 향상시키는 것이 중요합니다. 인덱스를 효과적으로 관리함으로써 데이터베이스의 쿼리 성능을 최적화할 수 있습니다.

---

MySQL은 다음 사진과 같이 중복되는 내용이 있음에도 계속해서 인덱스를 생성하기 때문에, 항상 중복 인덱스 인지 체크하면서 인덱스를 생성해야 합니다.

<img src="https://cdn-images-1.medium.com/max/800/1*qBoo822NkRgFzRYSd82fXg.png" />

Duplicate Indexes(중복 인덱스)와 Redundant Indexes(불필요한 인덱스)는 데이터베이스에서 인덱스를 관리하는데 있어서 발생할 수 있는 문제들을 설명합니다.

1. Duplicate Indexes (중복 인덱스):
   중복 인덱스란 동일한 데이터베이스 테이블에 동일한 컬럼 또는 컬럼의 조합에 대해 여러 개의 인덱스가 중복되어 생성되는 상황을 의미합니다. 즉, 같은 컬럼 또는 컬럼들에 대해 여러 개의 동일한 인덱스가 존재하는 것을 말합니다. 중복 인덱스는 불필요한 데이터베이스 공간을 차지하고, 데이터 변경 작업에 불필요한 오버헤드를 유발하여 데이터베이스의 성능을 저하시킬 수 있습니다.

예를 들어, `customers` 테이블의 `name` 컬럼에 대해 인덱스가 두 개 이상 생성되어 있다면 중복 인덱스가 발생한 것입니다. 이 경우에는 중복된 인덱스 중 하나를 제거하는 것이 좋습니다.

2. Redundant Indexes (불필요한 인덱스):
   불필요한 인덱스란 이미 다른 인덱스에 의해 커버링(covering)되거나, 중복 인덱스로 인해 더 이상 필요 없는 인덱스를 말합니다. 즉, 특정 인덱스가 이미 다른 인덱스의 사용으로 인해 불필요하게 중복되거나, 인덱스의 조합으로 이미 커버링되는 경우에 해당합니다. 불필요한 인덱스는 데이터베이스의 저장 공간을 낭비하고, 인덱스의 업데이트 비용을 증가시키므로 성능 저하를 초래할 수 있습니다.

불필요한 인덱스를 확인하고 제거하는 것은 데이터베이스 성능 최적화를 위해 중요한 작업입니다. 중복되거나 불필요한 인덱스를 식별하고 정리함으로써 데이터베이스의 리소스를 효율적으로 사용하고 쿼리 성능을 향상시킬 수 있습니다. 따라서 데이터베이스 설계 및 인덱스 관리를 신중하게 수행하여 중복 인덱스와 불필요한 인덱스를 최소화하는 것이 좋습니다.

각각의 파트에 대해 상세한 예시를 제공하겠습니다.

1. Duplicate Indexes (중복 인덱스):

예를 들어, `orders` 테이블에는 다음과 같이 두 개의 인덱스가 생성된 상태입니다.

- 인덱스 1: (order_id) 컬럼에 대한 단일 인덱스
- 인덱스 2: (order_id, customer_id) 컬럼에 대한 복합 인덱스

이때, 인덱스 2는 인덱스 1에 포함되어 있으므로 중복 인덱스가 발생하게 됩니다. 즉, 인덱스 1의 모든 엔트리들은 인덱스 2에서도 모두 중복되게 저장되어 있습니다. 이렇게 중복된 인덱스는 불필요한 저장 공간을 차지하고, 데이터 변경 작업에 불필요한 오버헤드를 유발할 수 있습니다.

해결 방법은 중복되는 인덱스 중 하나를 제거하는 것입니다. 위의 경우에서는 인덱스 1을 삭제하여 중복 인덱스 문제를 해결할 수 있습니다.

2. Redundant Indexes (불필요한 인덱스):

`products` 테이블에 다음과 같이 세 개의 인덱스가 생성되었습니다.

- 인덱스 1: (product_id) 컬럼에 대한 단일 인덱스
- 인덱스 2: (product_id, product_name) 컬럼에 대한 복합 인덱스
- 인덱스 3: (product_name) 컬럼에 대한 단일 인덱스

이때, 인덱스 2는 인덱스 1을 커버하고 있으며, 인덱스 3은 이미 인덱스 2의 첫 번째 컬럼과 같은 컬럼을 사용하고 있기 때문에 불필요한 인덱스가 됩니다. 즉, 인덱스 2가 이미 모든 인덱스 3의 데이터를 커버하고 있으므로, 인덱스 3은 중복되거나 불필요하게 또 다른 인덱스를 만드는 것입니다.

해결 방법은 불필요한 인덱스를 삭제하는 것입니다. 위의 경우에서는 인덱스 3을 삭제하여 불필요한 인덱스 문제를 해결할 수 있습니다.

중복 인덱스와 불필요한 인덱스는 데이터베이스의 성능에 영향을 미치므로 주기적으로 인덱스를 검토하고 최적화해야 합니다. 중복되거나 불필요한 인덱스를 식별하여 제거함으로써 데이터베이스의 리소스를 효율적으로 관리하고 쿼리 성능을 향상시킬 수 있습니다.

## Performance Best Practices

이 강좌에서 다룬 성능 최적화에 대한 모범 사례들을 요약해드리겠습니다. 이 리스트가 모든 사례를 포함하는 것은 아니지만, 성능 문제를 해결하는데 도움이 되는 지침들입니다. 더 자세히 알고 싶다면 이 문서에 있는 추가 자료들을 참고하시기 바랍니다.

1. 작은 테이블이 더 빠릅니다. 필요한 데이터만 저장하고, 미래에 필요하지 않을 데이터는 저장하지 않도록 합시다.
2. 가능한 한 작은 데이터 형식을 사용해보세요. 예를 들어, 나이를 저장해야 한다면 TINYINT가 적절합니다. INT를 사용할 필요가 없습니다. 작은 테이블에서는 몇 바이트를 절약하는 것이 큰 차이가 없지만, 수백만 개의 레코드가 있는 테이블에서는 큰 영향을 미칠 수 있습니다.
3. 모든 테이블에는 기본 키가 있어야 합니다.
4. 기본 키는 짧게 유지하는 것이 좋습니다. 예를 들어, 100개 레코드를 저장해야 한다면 INT 대신 TINYINT를 사용하세요.
5. 기본 키로는 숫자 형식을 선호해보세요. 이렇게 하면 기본 키를 사용하여 레코드를 빠르게 찾을 수 있습니다.
6. BLOB을 사용하는 것은 피하는 것이 좋습니다. 데이터베이스 크기를 증가시키고 성능에 영향을 미칠 수 있습니다. 가능하다면 파일은 디스크에 저장해보세요.
7. 하나의 테이블에 너무 많은 열이 있다면 일대일 관계를 사용하여 두 개의 관련된 테이블로 분리하는 것이 고려될 수 있습니다. 이를 수직 분할이라고 합니다.
8. 반대로, 데이터 조각화로 인해 많은 조인이 발생하는 경우 데이터 정규화와 반대되는 데이터 비정규화를 고려할 수 있습니다. 이는 테이블에서 하나의 열을 다른 테이블로 복제하는 것을 의미합니다.
9. 성능이 느린 쿼리에 대해서는 요약/캐시 테이블을 생성해보세요. 예를 들어, 게시판 목록과 게시물 수를 가져오는 쿼리가 비용이 많이 들 경우, forums_summary라는 테이블을 생성하여 이 정보를 저장할 수 있습니다. 이 테이블의 데이터는 정기적으로 갱신하는데 이벤트를 사용하거나, 새로운 게시물이 추가될 때마다 트리거를 사용할 수 있습니다.
10. 전체 테이블 스캔은 느린 쿼리의 주요 원인이 될 수 있습니다. EXPLAIN 문을 사용하여 type = ALL인 쿼리를 확인해보세요. 이는 전체 테이블 스캔을 의미합니다. 이러한 쿼리를 최적화하기 위해 인덱스를 사용해보세요.
11. 인덱스를 설계할 때는 먼저 WHERE 절에서 사용하는 컬럼을 살펴보세요. 이들이 검색을 좁히는 데에 도움이 됩니다. 그 다음, ORDER BY 절에서 사용하는 컬럼을 살펴보세요. 이들이 인덱스에 존재하면 MySQL은 정렬 작업을 수행하지 않고도 인덱스를 스캔하여 정렬된 데이터를 반환할 수 있습니다. 마지막으로, SELECT 절에서 사용하는 컬럼도 인덱스에 추가해보세요. 이렇게 하면 쿼리에 필요한 모든 것을 커버하는 커버링 인덱스를 얻을 수 있습니다. MySQL은 테이블에서 어떤 것도 검색하지 않아도 됩니다.
12. 단일 컬럼 인덱스보다는 복합 인덱스를 선호하세요.
13. 인덱스의 컬럼 순서가 중요합니다. 가장 자주 사용되는 컬럼과 기수(Cardinality)가 높은 컬럼을 먼저 위치시키세요. 그러나 항상 쿼리를 고려해보세요.
14. 중복된, 불필요한, 사용하지 않는 인덱스를 제거하세요. 중복된 인덱스는 같은 컬럼들의 동일한 순서로 인덱스가 중복되는 경우를 말합니다. 불필요한 인덱스는 이미 존재하는 인덱스로 대체할 수 있는 불필요한 인덱스를 의미합니다. 예를 들어, 컬럼 (A, B)에 인덱스가 있고 컬럼 (A)에 또 다른 인덱스를 생성하는 경우, 후자의 인덱스는 불필요합니다.
15. 기존 인덱스를 분석하기 전에 새로운 인덱스를 생성하지 마세요.
16. 쿼리에서 사용하는 컬럼을 고

려하여 인덱스를 선택하세요. 17. SELECT \*는 피하세요. 대부분의 경우 모든 컬럼을 선택하는 것은 인덱스를 무시하고 불필요한 컬럼까지 반환하는 결과를 가져옵니다. 이로 인해 데이터베이스 서버에 부하가 증가할 수 있습니다. 18. 필요한 행만 반환하세요. LIMIT 절을 사용하여 반환할 행의 수를 제한하세요. 19. LEADING wildcard를 사용하는 LIKE 표현식은 피하세요. (예: LIKE '%name') 20. OR 연산자를 사용하는 느린 쿼리의 경우, 쿼리를 두 개로 나누고 UNION 연산자를 사용하여 결합해보세요.

추가로 읽을만한 자료:

- "High Performance MySQL: Optimization, Backups, and Replication" by Baron Schwartz
- "Relational Database Index Design and the Optimizers" by Tapio Lahdenmaki
